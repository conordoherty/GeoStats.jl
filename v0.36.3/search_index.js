var documenterSearchIndex = {"docs":
[{"location":"about/community.html","page":"Community","title":"Community","text":"We use the Zulip platform to chat and help the community of users. Consider creating an account and pressing ? on the keyboard there for navigation instructions.","category":"page"},{"location":"about/community.html","page":"Community","title":"Community","text":"Click on the image to join the channel:","category":"page"},{"location":"about/community.html","page":"Community","title":"Community","text":"(Image: Zulip)","category":"page"},{"location":"resources/glossary.html#Glossary","page":"Glossary","title":"Glossary","text":"","category":"section"},{"location":"resources/glossary.html","page":"Glossary","title":"Glossary","text":"Below is a list of terms used consistently across the project. If you spot an inconsistency in a docstring, please report the issue or submit a pull request on GitHub.","category":"page"},{"location":"resources/glossary.html","page":"Glossary","title":"Glossary","text":"Term Description\ndomain Geospatial domain implementing the Meshes.Domain trait\ndata Geospatial data implementing the Meshes.data trait\nvar Name of a variable as a Symbol inside of data\nsdata Source data where a geostatistical model is trained\ntdata Target data where a geostatistical model is applied","category":"page"},{"location":"solvers/external.html#External","page":"External","title":"External","text":"","category":"section"},{"location":"solvers/external.html","page":"External","title":"External","text":"Below is the list of solvers that are available in external packages.","category":"page"},{"location":"solvers/external.html#Estimation","page":"External","title":"Estimation","text":"","category":"section"},{"location":"solvers/external.html#Simulation","page":"External","title":"Simulation","text":"","category":"section"},{"location":"solvers/external.html","page":"External","title":"External","text":"IQ\nTPS\nStratSim","category":"page"},{"location":"solvers/external.html#ImageQuilting.IQ","page":"External","title":"ImageQuilting.IQ","text":"IQ(var‚ÇÅ=>param‚ÇÅ, var‚ÇÇ=>param‚ÇÇ, ...)\n\nImage quilting simulation solver as described in Hoffimann et al. 2017.\n\nParameters\n\nRequired\n\ntrainimg - Training image from which to extract tiles\ntilesize - Tuple with tile size for each dimension\n\nOptional\n\noverlap  - Overlap size (default to (1/6, 1/6, ..., 1/6))\npath     - Simulation path (:raster (default), :dilation, or :random)\nmapping  - Data mapping method (default to NearestMapping())\ninactive - Vector of inactive voxels (i.e. CartesianIndex) in the grid\nsoft     - A pair (data,dataTI) of geospatial data objects (default to nothing)\ntol      - Initial relaxation tolerance in (0,1] (default to 0.1)\n\nGlobal parameters\n\nOptional\n\nthreads      - Number of threads in FFT (default to number of physical CPU cores)\nshowprogress - Whether to show or not the estimated time duration (default to false)\nrng          - Random number generator (default to Random.GLOBAL_RNG)\n\nReferences\n\nHoffimann et al 2017. Stochastic simulation by image quilting of process-based geological models.\nHoffimann et al 2015. Geostatistical modeling of evolving landscapes by means of image quilting.\n\n\n\n\n\n\n\n","category":"type"},{"location":"solvers/external.html#TuringPatterns.TPS","page":"External","title":"TuringPatterns.TPS","text":"TPS(var‚ÇÅ=>param‚ÇÅ, var‚ÇÇ=>param‚ÇÇ, ...)\n\nTuring pattern simulation.\n\nParameters\n\nparams - basic parameters (default to PARAMS1)\nblur   - blur algorithm (default to BoxBlur)\nedge   - edge condition (default to Clamp)\niter   - number of iterations (default to 100)\n\nReferences\n\nTuring 1952. The chemical basis of morphogenesis.\n\n\n\n\n\n\n\n","category":"type"},{"location":"solvers/external.html#StratiGraphics.StratSim","page":"External","title":"StratiGraphics.StratSim","text":"StratSim(var‚ÇÅ=>param‚ÇÅ, var‚ÇÇ=>param‚ÇÇ, ...)\n\nStratigraphy simulation with Markov-Poisson sampling.\n\nParameters\n\nenvironment - geological environment\nstate       - initial geological state\nstack       - stacking scheme (:erosional or :depositional)\nnepochs     - number of epochs (default to 10)\nfillbase    - fill value for the bottom layer (default to NaN)\nfilltop     - fill value for the top layer (default to NaN)\n\nReferences\n\nHoffimann 2018. Morphodynamic analysis and statistical synthesis of geormorphic data.\n\n\n\n\n\n\n\n","category":"type"},{"location":"solvers/external.html#Learning","page":"External","title":"Learning","text":"","category":"section"},{"location":"variography/empirical.html#Empirical-variograms","page":"Empirical variograms","title":"Empirical variograms","text":"","category":"section"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"An empirical variogram has the form:","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"hatgamma(h) = frac12N(h) sum_(ij) in N(h) (z_i - z_j)^2","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"where N(h) = left(ij) mid x_i - x_j = hright is the set of pairs of locations at a distance h and N(h) is the cardinality of the set. Empirical variograms can be estimated using general distance functions. These can be used in order to for example:","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"Model anisotropy (e.g. ellipsoid distance)\nPerform geostatistical simulation on spherical coordinate systems (e.g. haversine distance)","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"Please see Distances.jl for a complete list of options.","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"Additionally, given two empirical variograms hatgamma_alpha and hatgamma_beta, they can be merged as described in Hoffimann & Zadrozny 2019:","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"hatgamma_alpha+beta(h) =\nfracN_alpha(h) cdot hatgamma_alpha(h) + N_beta(h) cdot hatgamma_beta(h)N_alpha(h) + N_beta(h)","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"merge(::EmpiricalVariogram{D}, ::EmpiricalVariogram{D}) where {D}","category":"page"},{"location":"variography/empirical.html#Base.merge-Union{Tuple{D}, Tuple{EmpiricalVariogram{D}, EmpiricalVariogram{D}}} where D","page":"Empirical variograms","title":"Base.merge","text":"merge(Œ≥Œ±, Œ≥Œ≤)\n\nMerge the empirical variogram Œ≥Œ± with the empirical variogram Œ≥Œ≤ assuming that both variograms have the same number of lags.\n\n\n\n\n\n","category":"method"},{"location":"variography/empirical.html#Variograms","page":"Empirical variograms","title":"Variograms","text":"","category":"section"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"Consider the following image for illustration purposes:","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"using GeoStats # hide\nusing GeoStatsImages\nusing Plots # hide\nusing GeoStatsPlots # hide\ngr(size=(800,400),aspectratio=:equal) # hide\n\nùíü = geostatsimage(\"Gaussian30x10\")\n\nplot(ùíü)","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"EmpiricalVariogram","category":"page"},{"location":"variography/empirical.html#Variography.EmpiricalVariogram","page":"Empirical variograms","title":"Variography.EmpiricalVariogram","text":"EmpiricalVariogram(data, var‚ÇÅ, var‚ÇÇ=var‚ÇÅ; [optional parameters])\n\nComputes the empirical (a.k.a. experimental) omnidirectional (cross-)variogram for variables var‚ÇÅ and var‚ÇÇ stored in spatial data.\n\nParameters\n\nnlags    - number of lags (default to 20)\nmaxlag   - maximum lag (default to half of maximum lag of data)\ndistance - custom distance function (default to Euclidean distance)\nalgo     - accumulation algorithm (default to :ball)\n\nAvailable algorithms:\n\n:full - loop over all pairs of points in the data\n:ball - loop over all points inside maximum lag ball\n\nAll implemented algorithms produce the exact same result. The :ball algorithm is considerably faster when the maximum lag is much smaller than the bounding box of the data.\n\nThe function values can be used to retrieve the abscissa, ordinate and bin count of an empirical variogram:\n\njulia> x, y, n = values(Œ≥)\n\nSee also: DirectionalVariogram\n\nReferences\n\nChil√®s, JP and Delfiner, P. 2012. Geostatistics: Modeling Spatial Uncertainty\nHoffimann, J and Zadrozny, B. 2019. Efficient variography with partition variograms\n\n\n\n\n\n","category":"type"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"Œ≥ = EmpiricalVariogram(ùíü, :Z, maxlag=50.)\n\ngr(size=(800,400),aspectratio=:none) # hide\nplot(Œ≥)","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"DirectionalVariogram","category":"page"},{"location":"variography/empirical.html#Variography.DirectionalVariogram","page":"Empirical variograms","title":"Variography.DirectionalVariogram","text":"DirectionalVariogram(direction, data, var‚ÇÅ, var‚ÇÇ=var‚ÇÅ; dtol=1e-6, [parameters])\n\nComputes the empirical (cross-)variogram for the variables var‚ÇÅ and var‚ÇÇ stored in geospatial data along a given direction with band tolerance dtol.\n\nOptionally, forward parameters for the underlying EmpiricalVariogram.\n\n\n\n\n\n","category":"function"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"Œ≥‚Çï = DirectionalVariogram((1.,0.), ùíü, :Z, maxlag=50.)\nŒ≥·µ• = DirectionalVariogram((0.,1.), ùíü, :Z, maxlag=50.)\n\nplot(Œ≥‚Çï, label=\"horizontal\")\nplot!(Œ≥·µ•, label=\"vertical\")","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"PlanarVariogram","category":"page"},{"location":"variography/empirical.html#Variography.PlanarVariogram","page":"Empirical variograms","title":"Variography.PlanarVariogram","text":"PlanarVariogram(normal, data, var‚ÇÅ, var‚ÇÇ=var‚ÇÅ; ntol=1e-6, [parameters])\n\nComputes the empirical (cross-)variogram for the variables var‚ÇÅ and var‚ÇÇ stored in geospatial data along a plane perpendicular to a normal direction with plane tolerance ntol.\n\nOptionally, forward parameters for the underlying EmpiricalVariogram.\n\n\n\n\n\n","category":"function"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"Œ≥·µ• = PlanarVariogram((1.,0.), ùíü, :Z, maxlag=50.)\nŒ≥‚Çï = PlanarVariogram((0.,1.), ùíü, :Z, maxlag=50.)\n\nplot(Œ≥‚Çï, label=\"horizontal\")\nplot!(Œ≥·µ•, label=\"vertical\")","category":"page"},{"location":"variography/empirical.html#Varioplanes","page":"Empirical variograms","title":"Varioplanes","text":"","category":"section"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"EmpiricalVarioplane","category":"page"},{"location":"variography/empirical.html#Variography.EmpiricalVarioplane","page":"Empirical variograms","title":"Variography.EmpiricalVarioplane","text":"EmpiricalVarioplane(data, var‚ÇÅ, var‚ÇÇ=var‚ÇÅ;\n                    normal=spheredir(0,0),\n                    nangs=50, ptol=0.5, dtol=0.5,\n                    [parameters])\n\nGiven a normal direction, estimate the (cross-)variogram of variables var‚ÇÅ and var‚ÇÇ along all directions in the corresponding plane of variation.\n\nOptionally, specify the tolerance ptol for the plane partition, the tolerance dtol for the direction partition, the number of angles nangs in the plane, and forward the parameters to the underlying EmpiricalVariogram.\n\n\n\n\n\n","category":"type"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"Œ≥ = EmpiricalVarioplane(ùíü, :Z, maxlag=50.)\n\nplot(Œ≥)","category":"page"},{"location":"variography/theoretical.html#Theoretical-variograms","page":"Theoretical variograms","title":"Theoretical variograms","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"using GeoStats # hide\nusing Plots # hide\nusing GeoStatsPlots # hide","category":"page"},{"location":"variography/theoretical.html#Models","page":"Theoretical variograms","title":"Models","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"In an intrinsic isotropic model, the variogram is only a function of the distance between any two points x_1x_2 in R^m:","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(x_1x_2) = gamma(x_1 - x_2) = gamma(h)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"Under the additional assumption of 2nd-order stationarity, the well-known covariance is directly related via gamma(h) = cov(0) - cov(h). This package implements a few commonly used as well as other more exotic variogram models. Most of these models share a set of default parameters (e.g. sill=1.0, range=1.0), which can be set with keyword arguments.","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"Functions are provided to query properties of variogram models programatically:","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"isstationary(::Variogram)\nisisotropic(::Variogram)","category":"page"},{"location":"variography/theoretical.html#Variography.isstationary-Tuple{Variogram}","page":"Theoretical variograms","title":"Variography.isstationary","text":"isstationary(Œ≥)\n\nCheck if variogram Œ≥ possesses the 2nd-order stationary property.\n\n\n\n\n\n","category":"method"},{"location":"variography/theoretical.html#Meshes.isisotropic-Tuple{Variogram}","page":"Theoretical variograms","title":"Meshes.isisotropic","text":"isisotropic(Œ≥)\n\nTells whether or not variogram Œ≥ is isotropic.\n\n\n\n\n\n","category":"method"},{"location":"variography/theoretical.html#Gaussian","page":"Theoretical variograms","title":"Gaussian","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) left1 - expleft(-3left(frachrright)^2right)right + n cdot 1_(0infty)(h)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"GaussianVariogram","category":"page"},{"location":"variography/theoretical.html#Variography.GaussianVariogram","page":"Theoretical variograms","title":"Variography.GaussianVariogram","text":"GaussianVariogram(range=r, sill=s, nugget=n)\nGaussianVariogram(ball; sill=s, nugget=n)\n\nA Gaussian variogram with range r, sill s and nugget n. Optionally, use a custom metric ball.\n\n\n\n\n\n","category":"type"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"plot(GaussianVariogram())","category":"page"},{"location":"variography/theoretical.html#Exponential","page":"Theoretical variograms","title":"Exponential","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) left1 - expleft(-3left(frachrright)right)right + n cdot 1_(0infty)(h)\n","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"ExponentialVariogram","category":"page"},{"location":"variography/theoretical.html#Variography.ExponentialVariogram","page":"Theoretical variograms","title":"Variography.ExponentialVariogram","text":"ExponentialVariogram(range=r, sill=s, nugget=n)\nExponentialVariogram(ball; sill=s, nugget=n)\n\nAn exponential variogram with range r, sill s and nugget n. Optionally, use a custom metric ball.\n\n\n\n\n\n","category":"type"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"plot(ExponentialVariogram())","category":"page"},{"location":"variography/theoretical.html#Matern","page":"Theoretical variograms","title":"Matern","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) left1 - frac2^1-nuGamma(nu) left(sqrt2nufrachrright)^nu K_nuleft(sqrt2nufrachrright)right + n cdot 1_(0infty)(h)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"MaternVariogram","category":"page"},{"location":"variography/theoretical.html#Variography.MaternVariogram","page":"Theoretical variograms","title":"Variography.MaternVariogram","text":"MaternVariogram(range=r, sill=s, nugget=n, order=ŒΩ)\nMaternVariogram(ball; sill=s, nugget=n, order=ŒΩ)\n\nA Mat√©rn variogram with range r, sill s and nugget n. The parameter ŒΩ is the order of the Bessel function. Optionally, use a custom metric ball.\n\n\n\n\n\n","category":"type"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"plot(MaternVariogram())","category":"page"},{"location":"variography/theoretical.html#Spherical","page":"Theoretical variograms","title":"Spherical","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) leftleft(frac32left(frachrright) + frac12left(frachrright)^3right) cdot 1_(0r)(h) + 1_rinfty)(h)right + n cdot 1_(0infty)(h)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"SphericalVariogram","category":"page"},{"location":"variography/theoretical.html#Variography.SphericalVariogram","page":"Theoretical variograms","title":"Variography.SphericalVariogram","text":"SphericalVariogram(range=r, sill=s, nugget=n)\nSphericalVariogram(ball; sill=s, nugget=n)\n\nA spherical variogram with range r, sill s and nugget n. Optionally, use a custom metric ball.\n\n\n\n\n\n","category":"type"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"plot(SphericalVariogram())","category":"page"},{"location":"variography/theoretical.html#Cubic","page":"Theoretical variograms","title":"Cubic","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) leftleft(7left(frachrright)^2 - frac354left(frachrright)^3 + frac72left(frachrright)^5 - frac34left(frachrright)^7right) cdot 1_(0r)(h) + 1_rinfty)(h)right + n cdot 1_(0infty)(h)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"CubicVariogram","category":"page"},{"location":"variography/theoretical.html#Variography.CubicVariogram","page":"Theoretical variograms","title":"Variography.CubicVariogram","text":"CubicVariogram(range=r, sill=s, nugget=n)\nCubicVariogram(ball; sill=s, nugget=n)\n\nA cubic variogram with range r, sill s and nugget n. Optionally, use a custom metric ball.\n\n\n\n\n\n","category":"type"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"plot(CubicVariogram())","category":"page"},{"location":"variography/theoretical.html#Pentaspherical","page":"Theoretical variograms","title":"Pentaspherical","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) leftleft(frac158left(frachrright) - frac54left(frachrright)^3 + frac38left(frachrright)^5right) cdot 1_(0r)(h) + 1_rinfty)(h)right + n cdot 1_(0infty)(h)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"PentasphericalVariogram","category":"page"},{"location":"variography/theoretical.html#Variography.PentasphericalVariogram","page":"Theoretical variograms","title":"Variography.PentasphericalVariogram","text":"PentasphericalVariogram(range=r, sill=s, nugget=n)\nPentasphericalVariogram(ball; sill=s, nugget=n)\n\nA pentaspherical variogram with range r, sill s and nugget n. Optionally, use a custom metric ball.\n\n\n\n\n\n","category":"type"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"plot(PentasphericalVariogram())","category":"page"},{"location":"variography/theoretical.html#Power","page":"Theoretical variograms","title":"Power","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = sh^a + n cdot 1_(0infty)(h)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"PowerVariogram","category":"page"},{"location":"variography/theoretical.html#Variography.PowerVariogram","page":"Theoretical variograms","title":"Variography.PowerVariogram","text":"PowerVariogram(scaling=s, exponent=a, nugget=n)\n\nA power variogram with scaling s, exponent a and nugget n.\n\n\n\n\n\n","category":"type"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"plot(PowerVariogram())","category":"page"},{"location":"variography/theoretical.html#Sine-hole","page":"Theoretical variograms","title":"Sine hole","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) left1 - fracsin(pi h  r)pi h  rright + n cdot 1_(0infty)(h)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"SineHoleVariogram","category":"page"},{"location":"variography/theoretical.html#Variography.SineHoleVariogram","page":"Theoretical variograms","title":"Variography.SineHoleVariogram","text":"SineHoleVariogram(range=r, sill=s, nugget=n)\nSineHoleVariogram(ball; sill=s, nugget=n)\n\nA sine hole variogram with range r, sill s and nugget n. Optionally, use a custom metric ball.\n\n\n\n\n\n","category":"type"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"plot(SineHoleVariogram())","category":"page"},{"location":"variography/theoretical.html#Nugget","page":"Theoretical variograms","title":"Nugget","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = n cdot 1_(0infty)(h)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"NuggetEffect","category":"page"},{"location":"variography/theoretical.html#Variography.NuggetEffect","page":"Theoretical variograms","title":"Variography.NuggetEffect","text":"NuggetEffect(nugget=n)\n\nA pure nugget effect variogram with nugget n.\n\n\n\n\n\n","category":"type"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"plot(NuggetEffect(1.0))","category":"page"},{"location":"variography/theoretical.html#Anisotropy","page":"Theoretical variograms","title":"Anisotropy","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"Anisotropic models are easily obtained by defining an ellipsoid metric in place of the default Euclidean metric as shown in the following example. First, we create a custom metric ball, which specifies the ranges and angles of rotation of the ellipsoid:","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"ellipsoid = MetricBall((3.0, 2.0, 1.0), EulerAngles(0.0, 0.0, 0.0))","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"We then pass this ball as the first argument to the variogram model instead of specifying a single range with a keyword argument:","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"GaussianVariogram(ellipsoid, sill=2.0)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"To illustrate the concept, consider the following 2D data set:","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"using Random # hide\nRandom.seed!(2000) # hide\ndim, nobs = 2, 50\ntable = (Z=rand(nobs),)\ncoord = 100rand(dim, nobs)\n\nùíÆ = georef(table, coord)\n\nplot(ùíÆ)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"and the corresponding estimation problem on a Cartesian grid:","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"problem = EstimationProblem(ùíÆ, CartesianGrid(100,100), :Z)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"We solve the problem with different ellipsoids by varying the angle of rotation from 0 to 2pi clockwise:","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"anim = @animate for Œ∏ in range(0, stop=2œÄ, length=10)\n  # ellipsoid rotated clockwise by angle Œ∏\n  e = MetricBall((20.,5.), ClockwiseAngle(Œ∏))\n\n  # anisotropic variogram model\n  Œ≥ = GaussianVariogram(e)\n\n  # solve the problem with Kriging\n  sol = solve(problem, Kriging(:Z => (variogram=Œ≥,)))\n\n  # plot current frame\n  plot(sol)\nend\n\n# generate gif from list of frames\ngif(anim, \"anisotropy.gif\", fps=1)","category":"page"},{"location":"variography/theoretical.html#Nesting","page":"Theoretical variograms","title":"Nesting","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"A nested variogram model gamma(h) = c_1cdotgamma_1(h) + c_2cdotgamma_2(h) + cdots + c_ncdotgamma_n(h) can be constructed from multiple variogram models, including matrix coefficients:","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"Œ≥‚ÇÅ = GaussianVariogram()\nŒ≥‚ÇÇ = ExponentialVariogram()\n\n# nested model\nŒ≥ = [1.0 0.0; 0.0 1.0] * Œ≥‚ÇÅ + [2.0 0.5; 0.5 3.0] * Œ≥‚ÇÇ","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"The individual structures can be recovered in canonical form with the structures function:","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"structures","category":"page"},{"location":"variography/theoretical.html#Variography.structures","page":"Theoretical variograms","title":"Variography.structures","text":"structures(Œ≥)\n\nReturn the individual structures of a (possibly nested) variogram as a tuple. The structures are the total nugget c‚Çí, and the coefficients (or contributions) cs for the remaining non-trivial structures Œ≥s after normalization (i.e. sill=1, nugget=0).\n\n\n\n\n\n","category":"function"},{"location":"pointpatterns/pointops.html#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"pointpatterns/pointops.html","page":"Operations","title":"Operations","text":"Below is the list of currently implemented operations for point processes and patterns.","category":"page"},{"location":"pointpatterns/pointops.html#Superposition","page":"Operations","title":"Superposition","text":"","category":"section"},{"location":"pointpatterns/pointops.html","page":"Operations","title":"Operations","text":"The union or (superposition) of two point processes creates a union process:","category":"page"},{"location":"pointpatterns/pointops.html","page":"Operations","title":"Operations","text":"Base.union(::PointProcess, ::PointProcess)","category":"page"},{"location":"pointpatterns/pointops.html#Base.union-Tuple{PointProcess, PointProcess}","page":"Operations","title":"Base.union","text":"p‚ÇÅ ‚à™ p‚ÇÇ\n\nReturn the union of point processes p‚ÇÅ and p‚ÇÇ.\n\n\n\n\n\n","category":"method"},{"location":"pointpatterns/pointops.html#Thinning","page":"Operations","title":"Thinning","text":"","category":"section"},{"location":"pointpatterns/pointops.html","page":"Operations","title":"Operations","text":"The thin function implements the thinning operation for point processes and patterns. Below are the available thinning methods.","category":"page"},{"location":"pointpatterns/pointops.html","page":"Operations","title":"Operations","text":"thin\nRandomThinning","category":"page"},{"location":"pointpatterns/pointops.html#PointPatterns.thin","page":"Operations","title":"PointPatterns.thin","text":"thin(p, t)\n\nThin spatial point process p with thinning method t.\n\n\n\n\n\n","category":"function"},{"location":"pointpatterns/pointops.html#PointPatterns.RandomThinning","page":"Operations","title":"PointPatterns.RandomThinning","text":"RandomThinning(p)\n\nRandom thining with retention probability p.\n\n\n\n\n\n","category":"type"},{"location":"links.html#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"links.html","page":"Index","title":"Index","text":"Below is the list of types and functions mentioned in the documentation.","category":"page"},{"location":"links.html#Types","page":"Index","title":"Types","text":"","category":"section"},{"location":"links.html","page":"Index","title":"Index","text":"Order = [:type]","category":"page"},{"location":"links.html#Functions","page":"Index","title":"Functions","text":"","category":"section"},{"location":"links.html","page":"Index","title":"Index","text":"Order = [:function]","category":"page"},{"location":"data.html#Geospatial-data","page":"Data","title":"Geospatial data","text":"","category":"section"},{"location":"data.html#Overview","page":"Data","title":"Overview","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"Given a table or array containing data, we can georeference these objects onto a geospatial domain with the georef function. For a list of available domains, please see Domains.","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"georef","category":"page"},{"location":"data.html#GeoStatsBase.georef","page":"Data","title":"GeoStatsBase.georef","text":"georef(table, domain)\n\nGeoreference table on geospatial domain.\n\n\n\n\n\ngeoref(table, elems)\n\nGeoreference table on vector of elements elems, i.e. geometries or points.\n\n\n\n\n\ngeoref(table, coords)\n\nGeoreference table on a PointSet(coords).\n\n\n\n\n\ngeoref(table, coordnames)\n\nGeoreference table using columns coordnames.\n\n\n\n\n\ngeoref(tuple; origin=(0.,0.,...), spacing=(1.,1.,...))\n\nGeoreference named tuple on CartesianGrid(size(tuple[1]), origin, spacing).\n\n\n\n\n\n","category":"function"},{"location":"data.html","page":"Data","title":"Data","text":"In the opposite direction, the functions values and domain can be used to retrieve the table of attributes and the underlying geospatial domain.","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"values\ndomain","category":"page"},{"location":"data.html#Base.values","page":"Data","title":"Base.values","text":"values(data, [rank])\n\nReturn the values of data for a given rank as a table.\n\nThe rank is a non-negative integer that specifies the parametric dimension of the geometries of interest:\n\n0 - points\n1 - segments\n2 - triangles, quadrangles, ...\n3 - tetrahedrons, hexahedrons, ...\n\nIf the rank is not specified, it is assumed to be the rank of the elements of the domain.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Meshes.domain","page":"Data","title":"Meshes.domain","text":"domain(data)\n\nReturn underlying domain of the data.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Examples","page":"Data","title":"Examples","text":"","category":"section"},{"location":"data.html#Tables","page":"Data","title":"Tables","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"Consider a table (e.g. DataFrame) with 25 samples of temperature and precipitation:","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"using DataFrames\nusing GeoStats # hide\nusing Plots # hide\nusing GeoStatsPlots # hide\n\ntable = DataFrame(T=rand(25), P=rand(25))","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"We can georeference this table based on a given set of coordinates:","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"ùíü = georef(table, PointSet(rand(2,25)))\n\nplot(ùíü)","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"or alternatively, georeference it on a 5x5 regular grid (5x5 = 25 samples):","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"ùíü = georef(table, CartesianGrid(5,5))\n\nplot(ùíü)","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"In the first case, the PointSet domain type can be omitted, and GeoStats.jl will understand that the matrix passed as the second argument contains the coordinates of a point set:","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"ùíü = georef(table, rand(2,25))","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"Another common pattern in spatial data sets is when the coordinates of the samples are already part of the table as columns. In this case, we can specify the column names as symbols:","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"table = DataFrame(T=rand(25), P=rand(25), X=rand(25), Y=rand(25), Z=rand(25))\n\nùíü = georef(table, (:X,:Y,:Z))\n\nplot(ùíü)","category":"page"},{"location":"data.html#Arrays","page":"Data","title":"Arrays","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"Consider arrays (e.g. images) with data for various spatial variables. We can georeference these arrays using a named tuple, and GeoStats.jl will understand that the shape of the arrays should be preserved in a Cartesian grid:","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"T, P = rand(5,5), rand(5,5)\n\nùíü = georef((T=T, P=P))\n\nplot(ùíü)","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"We can also specify the origin and spacing of the grid using keyword arguments:","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"ùíü‚ÇÅ = georef((T=T, P=P), origin=(0.,0.), spacing=(1.,1.))\nùíü‚ÇÇ = georef((T=T, P=P), origin=(10.,10.), spacing=(2.,2.))\n\nplot(ùíü‚ÇÅ)\nplot!(ùíü‚ÇÇ)","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"Alternatively, we can interpret the entries of the named tuple as columns in a table:","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"ùíü = georef((T=T, P=T), rand(2,25))\n\nplot(ùíü)","category":"page"},{"location":"data.html#Shapefiles","page":"Data","title":"Shapefiles","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"The GeoTables.jl package can be used to load geospatial data from various file formats. It also provides utility functions to automatically download maps given the name of any region in the world.","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"We can load a shapefile as a geospatial table that is compatible with the framework:","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"using GeoTables\nusing GeoStats # hide\nusing Plots # hide\n\nzone = GeoTables.load(\"data/zone.shp\")","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"path = GeoTables.load(\"data/path.shp\")","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"Unlike in previous examples where each row of the table was associated with simple geometries (e.g. Point or Quadrangle), here we have more complicated geometries to consider:","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"zone.geometry","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"We can visualize these geometries as the domain of the geospatial data as usual:","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"gr(size=(600,400)) # hide\nplot(domain(zone), fill=true, color=:gray)\nplot!(domain(path), fill=true, color=:gray90)","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"and most importantly, nothing special needs to be done. This geospatial table can be used with any geostatistical workflow.","category":"page"},{"location":"data.html#Custom-data","page":"Data","title":"Custom data","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"GeoStats.jl is integrated with the Meshes.jl project. In summary, any type that is a subtype of Meshes.Data and that implements Meshes.domain and Meshes.values is compatible with the framework and can be used in geostatistical workflows.","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"Please ask in our community channels if you need help implementing custom geospatial data types.","category":"page"},{"location":"contributing/solvers.html#Writing-solvers","page":"Writing solvers","title":"Writing solvers","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"After reading this guide, you should be able to write your own geostatistical solver, and enjoy a large set of features for free, including distributed parallel execution, a suite of meta algorithms, and various plot recipes. If you have any questions, please don't hesitate to ask in our gitter channel.","category":"page"},{"location":"contributing/solvers.html#Basics","page":"Writing solvers","title":"Basics","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"Currently, there are three types of geostatistical problems defined in the framework:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"EstimationProblem\nSimulationProblem\nLearningProblem","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"The task of writing a solver for a geostatistical problem consists of writing a simple function in Julia that takes the problem as input and returns the solution. In the following sections we illustrate the development process and share working examples that could be copied/pasted as starters.","category":"page"},{"location":"contributing/solvers.html#Writing-estimation-solvers","page":"Writing solvers","title":"Writing estimation solvers","text":"","category":"section"},{"location":"contributing/solvers.html#Create-the-package","page":"Writing solvers","title":"Create the package","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"Install the PkgTemplates.jl package and create a new project:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using PkgTemplates\n\ngenerate_interactive(\"MySolver\")","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"This command will create a folder named ~/user/.julia/vx.y/MySolver with all the files that are necessary to load the new package:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using MySolver","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"Choose a license for your solver. If you don't have major restrictions, I suggest using the MIT license. Try to choose a permissive license so that your solver can be used, and improved by private corporations.","category":"page"},{"location":"contributing/solvers.html#Import-GeoStatsBase","page":"Writing solvers","title":"Import GeoStatsBase","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"After the package is created, open the main source file MySolver.jl and add the following lines:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using Meshes\nusing GeoStatsBase\nimport GeoStatsBase: solve","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"These lines bring all the symbols defined in Meshes and GeoStatsBase into scope, and tell Julia that the method solve will be specialized for the new solver. Next, give your solver a name:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"struct MyCoolSolver <: EstimationSolver\n  # optional parameters go here\nend","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"and export it so that it becomes available to users of your package:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"export MyCoolSolver","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"At this point, the MySolver.jl file should have the following content:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"module MySolver\n\nusing Meshes\nusing GeoStatsBase\nimport GeoStatsBase: solve\n\nexport MyCoolSolver\n\nstruct MyCoolSolver <: EstimationSolver\n  # optional parameters go here\nend\n\nend # module","category":"page"},{"location":"contributing/solvers.html#Write-the-algorithm","page":"Writing solvers","title":"Write the algorithm","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"Now that your solver type is defined, write your algorithm. Write a function called solve that takes an estimation problem and your solver, and returns an estimation solution:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"function solve(problem::EstimationProblem, solver::MyCoolSolver)\n  pdomain = domain(problem)\n\n  Œºs = []; œÉs = []\n  for var in name.(variables(problem))\n    push!(Œºs, var => rand(nelements(pdomain)))\n    push!(œÉs, Symbol(var,\"-variance\") => rand(nelements(pdomain)))\n  end\n\n  georef((; Œºs..., œÉs...), pdomain)\nend","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"Paste this function somewhere in your package, and you are all set.","category":"page"},{"location":"contributing/solvers.html#Test-the-solver","page":"Writing solvers","title":"Test the solver","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"To test your new solver, load the GeoStats.jl package and solve a simple problem:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using GeoStats\nusing MySolver\n\nsdata    = georef(CSV.File(\"samples.csv\"), (:x,:y))\nsdomain  = CartesianGrid(100, 100)\nproblem  = EstimationProblem(sdata, sdomain, :value)\n\nsolution = solve(problem, MyCoolSolver())\n\nplot(solution)","category":"page"},{"location":"contributing/solvers.html#Writing-simulation-solvers","page":"Writing solvers","title":"Writing simulation solvers","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"The process of writing a simulation solver is very similar, but there is an alternative function to solve called solvesingle that is preferred. The function solvesingle takes a simulation problem, one of the variables to be simulated, a solver, and a preprocessed input, and returns a vector with the simulation results:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"function solvesingle(problem::SimulationProblem, covars::NamedTuple,\n                     solver::MySimSolver, preproc)\n  # retrieve problem info\n  pdata = data(problem)\n  pdomain = domain(problem)\n\n  real4var = map(covars.names) do var\n    # output is a single realization for each covariable\n    real = Vector{Float64}(undef, nelements(pdomain))\n\n    # algorithm goes here\n    # ...\n\n    var => real\n  end\n\n  Dict(real4var)\nend","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"This function is preferred over solve if your algorithm is the same for every single realization (the algorithm is only a function of the random seed). In this case, GeoStats.jl will provide an implementation of solve for you that calls solvesingle in parallel.","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"The argument preproc is ignored unless the function preprocess is also defined for the solver. The function takes a simulation problem and a solver, and returns an arbitrary object with preprocessed data:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"preprocess(problem::SimulationProblem, solver::MySimSolver) = nothing","category":"page"},{"location":"contributing/solvers.html#Writing-learning-solvers","page":"Writing solvers","title":"Writing learning solvers","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"Similar to the other cases, writing a LearningSolver compatible with the framework consists of writing a simple Julia function that takes the LearningProblem as input along with the solver, and returns spatial data with learned variables.","category":"page"},{"location":"contributing/solvers.html#Examples","page":"Writing solvers","title":"Examples","text":"","category":"section"},{"location":"contributing/solvers.html#Estimation","page":"Writing solvers","title":"Estimation","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"An estimation solver that, for each location of the domain, assigns the 2-norm of the coordinates as the mean and the ‚àû-norm as the variance.","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using Meshes\nusing GeoStatsBase\nusing LinearAlgebra: norm\n\n# implement method for new solver\nimport GeoStatsBase: solve\n\n@estimsolver NormSolver begin\n  @param pmean = 2\n  @param pvar  = Inf\nend\n\nfunction solve(problem::EstimationProblem, solver::NormSolver)\n  pdomain = domain(problem)\n\n  # dictionary mapping variable names to types\n  mactypeof = Dict(name(v) => mactype(v) for v in variables(problem))\n\n  # results for each variable\n  Œºs = []; œÉs = []\n\n  for covars in covariables(problem, solver)\n    for var in covars.names\n      # get user parameters\n      varparams = covars.params[(var,)]\n\n      # get variable type\n      V = mactypeof[var]\n\n      # allocate memory for result\n      varŒº = Vector{V}(undef, nelements(pdomain))\n      varœÉ = Vector{V}(undef, nelements(pdomain))\n\n      for location in traverse(pdomain, LinearPath())\n        x = coordinates(centroid(pdomain, location))\n\n        varŒº[location] = norm(x, varparams.pmean)\n        varœÉ[location] = norm(x, varparams.pvar)\n      end\n\n      push!(Œºs, var => varŒº)\n      push!(œÉs, Symbol(var,\"-variance\") => varœÉ)\n    end\n  end\n\n  georef((; Œºs..., œÉs...), pdomain)\nend;","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"We can test the newly defined solver on an estimation problem:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using GeoStats\nusing Plots\ngr(size=(900,400)) # hide\n\n# dummy spatial data with a single point and no value\nsdata   = georef((z=[NaN],), reshape([0.,0.], 2, 1))\n\n# estimate on a regular grid\nsdomain = CartesianGrid(100, 100)\n\n# the problem to be solved\nproblem = EstimationProblem(sdata, sdomain, :z)\n\n# our new solver\nsolver = NormSolver()\n\nsolution = solve(problem, solver)\n\ncontourf(solution)","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"And assess the behavior of different parameters:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"solver = NormSolver(:z => (pmean=1,pvar=3))\n\nsolution = solve(problem, solver)\n\ncontourf(solution)","category":"page"},{"location":"contributing/solvers.html#Simulation","page":"Writing solvers","title":"Simulation","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"A simulation solver that, for each location of the domain, assigns a random sample from a Gaussian distribution.","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using Meshes\nusing GeoStatsBase\n\n# implement method for new solver\nimport GeoStatsBase: solvesingle\n\n@simsolver RandSolver begin\n  @param mean = 0\n  @param var  = 1\nend\n\nfunction solvesingle(problem::SimulationProblem, covars::NamedTuple,\n                     solver::RandSolver, preproc)\n  pdomain = domain(problem)\n\n  real4var = map(covars.names) do var\n    # retrieve solver parameters\n    varparams = covars.params[(var,)]\n    Œº, œÉ¬≤ = varparams.mean, varparams.var\n\n    # i.i.d. samples ~ Normal(0,1)\n    z = rand(nelements(pdomain))\n\n    # rescale and return\n    var => Œº .+ sqrt(œÉ¬≤) .* z\n  end\n\n  Dict(real4var)\nend;","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"We can test the newly defined solver in a simulation problem:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using GeoStats\nusing Plots\ngr(size=(900,300)) # hide\n\n# simulate on a regular grid\nsdomain = CartesianGrid(100, 100)\n\n# the problem to be solved\nproblem = SimulationProblem(sdomain, :z => Float64, 3)\n\n# our new solver\nsolver = RandSolver(:z => (mean=10.,var=10.))\n\nsolution = solve(problem, solver)\n\nheatmap(solution)","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"Note, however, that we did not define the preprocess function for the solver. This function can be used to avoid recalculations for each realization, and to set default parameters for variables that are not explicitly set by users in the solver constructor:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"import GeoStatsBase: preprocess\n\nfunction preprocess(problem::SimulationProblem, solver::RandSolver)\n  preproc = Dict()\n  for covars in covariables(problem, solver)\n    for varname in covars.names\n      varparams = covars.params[(varname,)]\n      preproc[varname] = (mean=varparams.mean, var=varparams.var)\n    end\n  end\n\n  preproc\nend;","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"We can call the preprocess function on problems with multiple variables to check that the solver is producing default values for variables other than the one passed during construction:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"problem = SimulationProblem(sdomain, (:z=>Float64, :w=>Float64), 3)\n\npreprocess(problem, solver)","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"This preproc output is passed by GeoStats.jl as the last argument to the solvesingle function, which could be reimplemented as follows:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"function solvesingle(problem::SimulationProblem, covars::NamedTuple,\n                     solver::RandSolver, preproc)\n  pdomain = domain(problem)\n\n  real4var = map(covars.names) do var\n    # retrieve solver parameters\n    Œº, œÉ¬≤ = preproc[var]\n\n    # i.i.d. samples ~ Normal(0,1)\n    z = rand(nelements(pdomain))\n\n    # rescale and return\n    var => Œº .+ sqrt(œÉ¬≤) .* z\n  end\n\n  Dict(real4var)\nend;","category":"page"},{"location":"contributing/solvers.html#Learning","page":"Writing solvers","title":"Learning","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"A learning solver that copies the mean of a response variable defined in source data over to target data:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using Meshes\nusing GeoStatsBase\n\n# implement method for new solver\nimport GeoStatsBase: solve\n\n# new solver that copies the mean\nstruct MeanSolver <: LearningSolver end\n\nfunction solve(problem::LearningProblem, solver::MeanSolver)\n  # retrieve problem info\n  ptask  = task(problem)\n  feats  = collect(features(ptask))\n  sdata  = sourcedata(problem)\n  tdata  = targetdata(problem)\n  resp   = first(outputvars(ptask))\n\n  # mean of response over source data\n  Œº = mean(sdata[:,resp])\n\n  # copy the mean over target domain\n  Œºs = fill(Œº, nitems(tdata))\n\n  # new table of attributes\n  table = (; zip([resp], [Œºs])...)\n\n  # georeference new table\n  georef(table, domain(tdata))\nend;","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"We can test the newly defined solver in a learning problem:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using GeoStats\nusing Plots\ngr(size=(900,300)) # hide\n\n# create some values\nv = [10sin(i/10) + j for i in 1:100, j in 1:100]\n\n# source data has X and Y\nŒ©s = georef((X=v, Y=v))\n\n# target data only has X\nŒ©t = georef((X=v,))\n\n# regression from X to Y\nt = RegressionTask(:X, :Y)\n\n# learning problem\np = LearningProblem(Œ©s, Œ©t, t)\n\n# solve problem\nŒº = solve(p, MeanSolver())\n\nplot(plot(Œ©s), plot(Œº))","category":"page"},{"location":"resources/education.html#Education","page":"Education","title":"Education","text":"","category":"section"},{"location":"resources/education.html","page":"Education","title":"Education","text":"Geostatistics is often misunderstood as \"classical statistics applied to geospatial data\". To correct this unfortunate misunderstanding, the best we can do as a community is to list educational resources.","category":"page"},{"location":"resources/education.html#Learning-resources","page":"Education","title":"Learning resources","text":"","category":"section"},{"location":"resources/education.html#Books","page":"Education","title":"Books","text":"","category":"section"},{"location":"resources/education.html","page":"Education","title":"Education","text":"Isaaks, E. and Srivastava, R. 1990. An Introduction to Applied Geostatistics - An introductory book on geostatistics that covers important concepts with very simple language.\nChil√®s, JP and Delfiner, P. 2012. Geostatistics: Modeling Spatial Uncertainty - An incredible book for those with good mathematical background.\nJournel, A. and Huijbregts, Ch. 2003. Mining Geostatistics - A great book with both theoretical and practical developments.","category":"page"},{"location":"resources/education.html#Lectures","page":"Education","title":"Lectures","text":"","category":"section"},{"location":"resources/education.html","page":"Education","title":"Education","text":"J√∫lio Hoffimann - Video lectures with the GeoStats.jl project.\nEdward Isaaks - Video lectures on variography, Kriging and related concepts.\nJef Caers - Video lectures on two-point and multiple-point methods.","category":"page"},{"location":"resources/education.html#Workshops","page":"Education","title":"Workshops","text":"","category":"section"},{"location":"resources/education.html","page":"Education","title":"Education","text":"CBMina 2021 [Portuguese] - GeoStats.jl at the Brazilian mining congress.\nUFMG 2021 [Portuguese] - GeoStats.jl at the Federal University of Minas Gerais.","category":"page"},{"location":"resources/education.html#Related-concepts","page":"Education","title":"Related concepts","text":"","category":"section"},{"location":"resources/education.html#GaussianProcesses.jl","page":"Education","title":"GaussianProcesses.jl","text":"","category":"section"},{"location":"resources/education.html","page":"Education","title":"Education","text":"GaussianProcesses.jl - Gaussian process regression and Simple Kriging are essentially two names for the same concept. The derivation of Kriging estimators, however; does not require distributional assumptions. It is a beautiful coincidence that for multivariate Gaussian distributions, Simple Kriging gives the conditional expectation. Matheron and other important geostatisticians have generalized Gaussian processes to more general random fields with locally-varying mean and for situations where the mean is unknown. GeoStats.jl includes Gaussian processes as a special case as well as other more practical Kriging variants.","category":"page"},{"location":"resources/education.html#MLKernels.jl","page":"Education","title":"MLKernels.jl","text":"","category":"section"},{"location":"resources/education.html","page":"Education","title":"Education","text":"MLKernels.jl - Spatial structure can be represented in many different forms: covariance, variogram, correlogram, etc. Variograms are more general than covariance kernels according to the intrinsic stationary property. This means that there are variogram models with no covariance counterpart. Furthermore, empirical variograms can be easily estimated from the data (in various directions) with an efficient procedure. GeoStats.jl treats variograms as first-class objects.","category":"page"},{"location":"resources/education.html#Interpolations.jl","page":"Education","title":"Interpolations.jl","text":"","category":"section"},{"location":"resources/education.html","page":"Education","title":"Education","text":"Interpolations.jl - Kriging and spline interpolation have different purposes, yet these two methods are sometimes listed as competing alternatives. Kriging estimation is about minimizing variance (or estimation error), whereas spline interpolation is about deriving smooth estimators for computer visualization. Kriging is a generalization of splines in which one has the freedom to customize spatial structure based on data. Besides the estimate itself, Kriging also provides the variance map as a function of point patterns.","category":"page"},{"location":"resources/education.html#MLJ.jl","page":"Education","title":"MLJ.jl","text":"","category":"section"},{"location":"resources/education.html","page":"Education","title":"Education","text":"MLJ.jl - Traditional statistical learning relies on core assumptions that do not hold in geospatial settings (fixed support, i.i.d. samples, ...). Geostatistical learning has been introduced recently as an attempt to push the frontiers of statistical learning with geospatial data.","category":"page"},{"location":"ensembles.html#Ensembles","page":"Ensembles","title":"Ensembles","text":"","category":"section"},{"location":"ensembles.html","page":"Ensembles","title":"Ensembles","text":"Ensemble","category":"page"},{"location":"ensembles.html#GeoStatsBase.Ensemble","page":"Ensembles","title":"GeoStatsBase.Ensemble","text":"Ensemble\n\nAn ensemble of geostatistical realizations.\n\nThe result of a geostatistical simulation solver is a set of geospatial data (a.k.a. realizations). This set can be interpreted as an empirical approximation of the random field of interest.\n\nNotes\n\nEnsemble objects are typically created by a call to the solve function on a SimulationProblem.\n\n\n\n\n\n","category":"type"},{"location":"ensembles.html","page":"Ensembles","title":"Ensembles","text":"Consider the following solution to a conditional simulation problem:","category":"page"},{"location":"ensembles.html","page":"Ensembles","title":"Ensembles","text":"using GeoStats\nusing Plots, GeoStatsPlots\ngr(size=(900,400)) # hide\n\n# geospatial samples\nS = let\n  coord = [(25.,25.), (50.,75.), (75.,50.)]\n  table = (z=[1.,0.,1.],)\n  georef(table, coord)\nend\n\n# simulation domain\nD = CartesianGrid(100, 100)\n\n# request 100 realizations\nproblem = SimulationProblem(S, D, :z, 100)\n\n# LU Gaussian simulation\nsolver = LUGS(:z => (variogram=GaussianVariogram(range=30.),))\n\n# realizations form an ensemble\nensemble = solve(problem, solver)","category":"page"},{"location":"ensembles.html","page":"Ensembles","title":"Ensembles","text":"We can visualize a few realizations in the ensemble:","category":"page"},{"location":"ensembles.html","page":"Ensembles","title":"Ensembles","text":"z1 = ensemble[1]\nz2 = ensemble[2]\nz3 = ensemble[3]\nz4 = ensemble[4]\n\nplot(plot(z1), plot(z2),\n     plot(z3), plot(z4),\n     size=(900,800))","category":"page"},{"location":"ensembles.html","page":"Ensembles","title":"Ensembles","text":"or alternatively, the mean and variance:","category":"page"},{"location":"ensembles.html","page":"Ensembles","title":"Ensembles","text":"m = mean(ensemble)\nv = var(ensemble)\n\np1 = plot(m, title=\"mean\")\np2 = plot(v, title=\"variance\")\n\nplot(p1, p2)","category":"page"},{"location":"ensembles.html","page":"Ensembles","title":"Ensembles","text":"or the 25th and 75th percentiles:","category":"page"},{"location":"ensembles.html","page":"Ensembles","title":"Ensembles","text":"a = quantile(ensemble, 0.25)\nb = quantile(ensemble, 0.75)\n\np1 = plot(a, title=\"25th percentile\")\np2 = plot(b, title=\"75th percentile\")\n\nplot(p1, p2)","category":"page"},{"location":"ensembles.html","page":"Ensembles","title":"Ensembles","text":"All these objects are examples of geospatial data as described in the Data section.","category":"page"},{"location":"about/license.html","page":"License","title":"License","text":"The GeoStats.jl project is licensed under the MIT license:","category":"page"},{"location":"about/license.html","page":"License","title":"License","text":"MIT License\n\nCopyright (c) 2015 J√∫lio Hoffimann <julio.hoffimann@gmail.com> and contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","category":"page"},{"location":"pointpatterns/pointprocs.html#Processes","page":"Processes","title":"Processes","text":"","category":"section"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"Point processes can be simulated with the function rand on different geometries:","category":"page"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"Base.rand(::AbstractRNG, ::PointProcess, ::Geometry, ::Int)","category":"page"},{"location":"pointpatterns/pointprocs.html#Base.rand-Tuple{AbstractRNG, PointProcess, Geometry, Int64}","page":"Processes","title":"Base.rand","text":"rand([rng], p, g, n=1; [algo])\n\nGenerate n realizations of spatial point process p inside geometry g. Optionally specify sampling algorithm algo and random number generator rng.\n\n\n\n\n\n","category":"method"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"For example, a Poisson process with given intensity in a rectangular region:","category":"page"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"using GeoStats # hide\nusing Plots # hide\nusing GeoStatsPlots # hide\ngr(format=:svg) # hide\n\np = PoissonProcess(0.1)\nb = Box((0.,0.), (100.,100.))\n\ns = rand(p, b, 2)\n\nplot(plot(s[1]), plot(s[2]))","category":"page"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"or the superposition of two Binomial processes:","category":"page"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"p‚ÇÅ = BinomialProcess(50)\np‚ÇÇ = BinomialProcess(50)\np  = p‚ÇÅ ‚à™ p‚ÇÇ # 100 points\n\ns = rand(p, b, 2)\n\nplot(plot(s[1]), plot(s[2]))","category":"page"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"The homogeneity property of a point process can be checked with the ishomogeneous function:","category":"page"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"ishomogeneous","category":"page"},{"location":"pointpatterns/pointprocs.html#PointPatterns.ishomogeneous","page":"Processes","title":"PointPatterns.ishomogeneous","text":"ishomogeneous(p)\n\nTells whether or not the spatial point process p is homogeneous.\n\n\n\n\n\n","category":"function"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"Below is the list of currently implemented point processes.","category":"page"},{"location":"pointpatterns/pointprocs.html#BinomialProcess","page":"Processes","title":"BinomialProcess","text":"","category":"section"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"BinomialProcess","category":"page"},{"location":"pointpatterns/pointprocs.html#PointPatterns.BinomialProcess","page":"Processes","title":"PointPatterns.BinomialProcess","text":"BinomialProcess(n)\n\nA Binomial point process with n points.\n\n\n\n\n\n","category":"type"},{"location":"pointpatterns/pointprocs.html#PoissonProcess","page":"Processes","title":"PoissonProcess","text":"","category":"section"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"PoissonProcess","category":"page"},{"location":"pointpatterns/pointprocs.html#PointPatterns.PoissonProcess","page":"Processes","title":"PointPatterns.PoissonProcess","text":"PoissonProcess(Œª)\n\nA Poisson process with intensity Œª.\n\n\n\n\n\n","category":"type"},{"location":"pointpatterns/pointprocs.html#UnionProcess","page":"Processes","title":"UnionProcess","text":"","category":"section"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"UnionProcess","category":"page"},{"location":"pointpatterns/pointprocs.html#PointPatterns.UnionProcess","page":"Processes","title":"PointPatterns.UnionProcess","text":"UnionProcess(p‚ÇÅ, p‚ÇÇ)\n\nUnion (or superposition) of spatial point processes p‚ÇÅ and p‚ÇÇ.\n\n\n\n\n\n","category":"type"},{"location":"domains.html#Domains","page":"Domains","title":"Domains","text":"","category":"section"},{"location":"domains.html#Overview","page":"Domains","title":"Overview","text":"","category":"section"},{"location":"domains.html","page":"Domains","title":"Domains","text":"A geospatial domain is a region in physical space where data can be measured. For example, a collection of rain gauge stations can be represented as a point set in the map. Similarly, a collection of states in a given country can be represented as a set of 2D shapes.","category":"page"},{"location":"domains.html","page":"Domains","title":"Domains","text":"We provide flexible domain types for advanced geospatial workflows via the Meshes.jl project. Please check their documentation for more details.","category":"page"},{"location":"domains.html#Examples","page":"Domains","title":"Examples","text":"","category":"section"},{"location":"domains.html#PointSet","page":"Domains","title":"PointSet","text":"","category":"section"},{"location":"domains.html","page":"Domains","title":"Domains","text":"using GeoStats # hide\nusing Plots # hide\nusing GeoStatsPlots # hide\ngr(size=(600,600)) # hide\n\npset = PointSet(rand(3,100))","category":"page"},{"location":"domains.html","page":"Domains","title":"Domains","text":"plot(pset)","category":"page"},{"location":"domains.html#GeometrySet","page":"Domains","title":"GeometrySet","text":"","category":"section"},{"location":"domains.html","page":"Domains","title":"Domains","text":"t = Triangle((0.0,0.0), (1.0,1.0), (0.0,1.0))\nq = Quadrangle((1.0,1.0), (2.0,1.0), (2.0,2.0), (1.0,2.0))\n\ngset = GeometrySet([t, q])","category":"page"},{"location":"domains.html","page":"Domains","title":"Domains","text":"plot(gset, fillcolor=:gray90, linecolor=:black)","category":"page"},{"location":"domains.html#CartesianGrid","page":"Domains","title":"CartesianGrid","text":"","category":"section"},{"location":"domains.html","page":"Domains","title":"Domains","text":"grid = CartesianGrid(10,10,10)","category":"page"},{"location":"domains.html","page":"Domains","title":"Domains","text":"plot(grid)","category":"page"},{"location":"domains.html#SimpleMesh","page":"Domains","title":"SimpleMesh","text":"","category":"section"},{"location":"domains.html","page":"Domains","title":"Domains","text":"points = Point2[(0,0), (1,0), (0,1), (1,1), (0.25,0.5), (0.75,0.5)]\nconnec = connect.([(1,5,3),(4,6,2),(1,2,6,5),(4,3,5,6)], Ngon)\nmesh   = SimpleMesh(points, connec)","category":"page"},{"location":"domains.html","page":"Domains","title":"Domains","text":"plot(mesh, fillcolor=:gray90, linecolor=:black)","category":"page"},{"location":"kriging.html#Kriging","page":"Kriging","title":"Kriging","text":"","category":"section"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"note: Note\nThis section describes the estimators used in the Kriging solver. Most users don't want to use estimators directly because they lack features such as neighborhood search and change of support. If that is your case, please refer to the solver documentation.","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"A Kriging estimator has the form:","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"hatZ(x_0) = lambda_1 Z(x_1) + lambda_2 Z(x_2) + cdots + lambda_n Z(x_n)quad x_i in R^m lambda_i in R","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"with Zcolon R^m times Omega to R a random field.","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"This package implements the following Kriging variants:","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"Simple Kriging\nOrdinary Kriging\nUniversal Kriging\nExternal Drift Kriging","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"All these variants follow the same interface: an estimator object is first created with a given set of parameters, it is then combined with the data to obtain predictions at new locations.","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"The fit function takes care of building the Kriging system and factorizing the LHS with an appropriate decomposition (e.g. Cholesky, LU):","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"fit(::KrigingEstimator, ::Any)","category":"page"},{"location":"kriging.html#StatsAPI.fit-Tuple{KrigingEstimator, Any}","page":"Kriging","title":"StatsAPI.fit","text":"fit(estimator, data)\n\nBuild Kriging system from data and return a fitted estimator.\n\n\n\n\n\n","category":"method"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"and the predict function performs the estimation for a given variable and location:","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"predict(::KrigingEstimators.FittedKriging, ::Any, ::Any)\npredictprob(::KrigingEstimators.FittedKriging, ::Any, ::Any)","category":"page"},{"location":"kriging.html#GeoStatsBase.predict-Tuple{KrigingEstimators.FittedKriging, Any, Any}","page":"Kriging","title":"GeoStatsBase.predict","text":"predict(estimator, var, u‚Çí)\n\nCompute mean and variance of variable var using the estimator at point or geometry u‚Çí.\n\n\n\n\n\n","category":"method"},{"location":"kriging.html#GeoStatsBase.predictprob-Tuple{KrigingEstimators.FittedKriging, Any, Any}","page":"Kriging","title":"GeoStatsBase.predictprob","text":"predictprob(estimator, var, u‚Çí)\n\nCompute the Normal distribution with Kriging mean and variance obtained with predict.\n\n\n\n\n\n","category":"method"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"Alternative constructors are provided for convenience that will immediately fit the Kriging parameters to the data. In this case, the data is passed as the first argument.","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"For advanced users, the Kriging weights and Lagrange multipliers at a given location can be accessed with the weights method. This method returns a KrigingWeights object containing a field Œª for the weights and a field ŒΩ for the Lagrange multipliers:","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"weights","category":"page"},{"location":"kriging.html#KrigingEstimators.weights","page":"Kriging","title":"KrigingEstimators.weights","text":"weights(estimator, u‚Çí)\n\nCompute the weights Œª (and Lagrange multipliers ŒΩ) for the estimator at point or geometry u‚Çí.\n\n\n\n\n\n","category":"function"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"These weights can be combined with a vector of observations using the combine function:","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"KrigingEstimators.combine","category":"page"},{"location":"kriging.html#KrigingEstimators.combine","page":"Kriging","title":"KrigingEstimators.combine","text":"combine(estimator, weights, z)\n\nCombine weights with values z to produce mean and variance using the appropriate formulas for the estimator.\n\n\n\n\n\n","category":"function"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"This functionality can be useful in real-time applications when the locations of the observations are fixed and an online stream of data is available.","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"Finally, all estimators work with general Hilbert spaces, meaning that one can interpolate any data type that implements scalar multiplication, vector addition and inner product.","category":"page"},{"location":"kriging.html#Simple-Kriging","page":"Kriging","title":"Simple Kriging","text":"","category":"section"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"In Simple Kriging, the mean mu of the random field is assumed to be constant and known. The resulting linear system is:","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"beginbmatrix\ncov(x_1x_1)  cov(x_1x_2)  cdots  cov(x_1x_n) \ncov(x_2x_1)  cov(x_2x_2)  cdots  cov(x_2x_n) \nvdots  vdots  ddots  vdots \ncov(x_nx_1)  cov(x_nx_2)  cdots  cov(x_nx_n)\nendbmatrix\nbeginbmatrix\nlambda_1 \nlambda_2 \nvdots \nlambda_n\nendbmatrix\n=\nbeginbmatrix\ncov(x_1x_0) \ncov(x_2x_0) \nvdots \ncov(x_nx_0)\nendbmatrix","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"or in matricial form Cl = c. We subtract the given mean from the observations boldsymboly = z - mu 1 and compute the mean and variance at location x_0:","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"mu(x_0) = mu + boldsymboly^top l","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"sigma^2(x_0) = cov(0) - c^top l","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"SimpleKriging","category":"page"},{"location":"kriging.html#KrigingEstimators.SimpleKriging","page":"Kriging","title":"KrigingEstimators.SimpleKriging","text":"SimpleKriging(Œ≥, Œº)\nSimpleKriging(data, Œ≥, Œº)\n\nSimple Kriging with variogram model Œ≥ and constant mean Œº.\n\nOptionally, pass the geospatial data to the fit function.\n\nNotes\n\nSimple Kriging requires stationary variograms\n\n\n\n\n\n","category":"type"},{"location":"kriging.html#Ordinary-Kriging","page":"Kriging","title":"Ordinary Kriging","text":"","category":"section"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"In Ordinary Kriging the mean of the random field is assumed to be constant and unknown. The resulting linear system is:","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"beginbmatrix\nG  1 \n1^top  0\nendbmatrix\nbeginbmatrix\nl \nnu\nendbmatrix\n=\nbeginbmatrix\ng \n1\nendbmatrix","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"with nu the Lagrange multiplier associated with the constraint 1^top l = 1. The mean and variance at location x_0 are given by:","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"mu(x_0) = z^top l","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"sigma^2(x_0) =  beginbmatrix g  1 endbmatrix^top beginbmatrix l  nu endbmatrix","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"OrdinaryKriging","category":"page"},{"location":"kriging.html#KrigingEstimators.OrdinaryKriging","page":"Kriging","title":"KrigingEstimators.OrdinaryKriging","text":"OrdinaryKriging(Œ≥)\nOrdinaryKriging(data, Œ≥)\n\nOrdinary Kriging with variogram model Œ≥.\n\nOptionally, pass the geospatial data to the fit function.\n\n\n\n\n\n","category":"type"},{"location":"kriging.html#Universal-Kriging","page":"Kriging","title":"Universal Kriging","text":"","category":"section"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"In Universal Kriging, the mean of the random field is assumed to be a polynomial of the spatial coordinates:","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"mu(x) = sum_k=1^N_d beta_k f_k(x)","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"with N_d monomials f_k of degree up to d. For example, in 2D there are 6 monomials of degree up to 2:","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"mu(x_1x_2) =  beta_1 1 + beta_2 x_1 + beta_3 x_2 + beta_4 x_1 x_2 + beta_5 x_1^2 + beta_6 x_2^2","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"The choice of the degree d determines the size of the polynomial matrix","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"F =\nbeginbmatrix\nf_1(x_1)  f_2(x_1)  cdots  f_N_d(x_1) \nf_1(x_2)  f_2(x_2)  cdots  f_N_d(x_2) \nvdots  vdots  ddots  vdots \nf_1(x_n)  f_2(x_n)  cdots  f_N_d(x_n)\nendbmatrix","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"and polynomial vector f = beginbmatrix f_1(x_0)  f_2(x_0)  cdots  f_N_d(x_0) endbmatrix^top.","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"The variogram determines the variogram matrix:","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"G =\nbeginbmatrix\ngamma(x_1x_1)  gamma(x_1x_2)  cdots  gamma(x_1x_n) \ngamma(x_2x_1)  gamma(x_2x_2)  cdots  gamma(x_2x_n) \nvdots  vdots  ddots  vdots \ngamma(x_nx_1)  gamma(x_nx_2)  cdots  gamma(x_nx_n)\nendbmatrix","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"and the variogram vector g = beginbmatrix gamma(x_1x_0)  gamma(x_2x_0)  cdots  gamma(x_nx_0) endbmatrix^top.","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"The resulting linear system is:","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"beginbmatrix\nG  F \nF^top  boldsymbol0\nendbmatrix\nbeginbmatrix\nl \nboldsymbolnu\nendbmatrix\n=\nbeginbmatrix\ng \nf\nendbmatrix","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"with boldsymbolnu the Lagrange multipliers associated with the universal constraints. The mean and variance at location x_0 are given by:","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"mu(x_0) = z^top l","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"sigma^2(x_0) = beginbmatrixg  fendbmatrix^top beginbmatrixl  boldsymbolnuendbmatrix","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"UniversalKriging","category":"page"},{"location":"kriging.html#KrigingEstimators.UniversalKriging","page":"Kriging","title":"KrigingEstimators.UniversalKriging","text":"UniversalKriging(Œ≥, degree, dim)\nUniversalKriging(data, Œ≥, degree)\n\nUniversal Kriging with variogram model Œ≥ and polynomial degree on a spatial domain of dimension dim.\n\nOptionally, pass the geospatial data to the fit function.\n\nNotes\n\nOrdinaryKriging is recovered for 0th degree polynomial\nFor non-polynomial mean, see ExternalDriftKriging\n\n\n\n\n\n","category":"type"},{"location":"kriging.html#External-Drift-Kriging","page":"Kriging","title":"External Drift Kriging","text":"","category":"section"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"In External Drift Kriging, the mean of the random field is assumed to be a combination of known smooth functions:","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"mu(x) = sum_k beta_k m_k(x)","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"Differently than Universal Kriging, the functions m_k are not necessarily polynomials of the spatial coordinates. In practice, they represent a list of variables that is strongly correlated (and co-located) with the variable being estimated.","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"External drifts are known to cause numerical instability. Give preference to other Kriging variants if possible.","category":"page"},{"location":"kriging.html","page":"Kriging","title":"Kriging","text":"ExternalDriftKriging","category":"page"},{"location":"kriging.html#KrigingEstimators.ExternalDriftKriging","page":"Kriging","title":"KrigingEstimators.ExternalDriftKriging","text":"ExternalDriftKriging(Œ≥, drifts)\nExternalDriftKriging(data, Œ≥, drifts)\n\nExternal Drift Kriging with variogram model Œ≥ and external drifts functions.\n\nOptionally, pass the geospatial data to the fit function.\n\nNotes\n\nExternal drift functions should be smooth\nKriging system with external drift is often unstable\nInclude a constant drift (e.g. x->1) for unbiased estimation\nOrdinaryKriging is recovered for drifts = [x->1]\nFor polynomial mean, see UniversalKriging\n\n\n\n\n\n","category":"type"},{"location":"splitapplycombine.html#Split-apply-combine","page":"Split-apply-combine","title":"Split-apply-combine","text":"","category":"section"},{"location":"splitapplycombine.html","page":"Split-apply-combine","title":"Split-apply-combine","text":"We provide a geospatial version of the split-apply-combine pattern:","category":"page"},{"location":"splitapplycombine.html","page":"Split-apply-combine","title":"Split-apply-combine","text":"<p align=\"center\">\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/1opCT2lId88\" title=\"Geodata Science\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</p>","category":"page"},{"location":"splitapplycombine.html","page":"Split-apply-combine","title":"Split-apply-combine","text":"@groupby\n@transform\n@combine","category":"page"},{"location":"splitapplycombine.html#GeoStatsBase.@groupby","page":"Split-apply-combine","title":"GeoStatsBase.@groupby","text":"@groupby(data, col‚ÇÅ, col‚ÇÇ, ..., col‚Çô)\n@groupby(data, [col‚ÇÅ, col‚ÇÇ, ..., col‚Çô])\n@groupby(data, (col‚ÇÅ, col‚ÇÇ, ..., col‚Çô))\n\nPartition geospatial data according to selected columns col‚ÇÅ, col‚ÇÇ, ..., col‚Çô.\n\n@groupby(data, regex)\n\nPartition geospatial data according to columns that match with regex.\n\nExamples\n\n@groupby(data, 1, 3, 5)\n@groupby(data, [:a, :c, :e])\n@groupby(data, (\"a\", \"c\", \"e\"))\n@groupby(data, r\"[ace]\")\n\n\n\n\n\n","category":"macro"},{"location":"splitapplycombine.html#GeoStatsBase.@transform","page":"Split-apply-combine","title":"GeoStatsBase.@transform","text":"@transform(object, :col‚ÇÅ = expr‚ÇÅ, :col‚ÇÇ = expr‚ÇÇ, ..., :col‚Çô = expr‚Çô)\n\nReturn a new Data or Partition object with object columns  and new columns col‚ÇÅ, col‚ÇÇ, ..., col‚Çô defined by expressions expr‚ÇÅ, expr‚ÇÇ, ..., expr‚Çô. The object can be a Data object or a Partition object returned by the @groupby macro. In each expression the object columns are represented by symbols  and the functions use broadcast by default. Also, is pissible pass strings  or variables as column names using the {colname} syntax. If there are columns  in the table with the same name as the new columns, these will be replaced.\n\nSee also: @groupby.\n\nExamples\n\n@transform(data, :z = :x + 2*:y)\n@transform(data, :w = :x^2 - :y^2)\n@transform(data, :sinx = sin(:x), :cosy = cos(:y))\n\np = @groupby(data, :y)\n@transform(p, :logx = log(:x))\n@transform(p, :expz = exp(:z))\n\n@transform(data, {\"z\"} = {\"x\"} - 2*{\"y\"})\nxnm, ynm, znm = :x, :y, :z\n@transform(data, {znm} = {xnm} - 2*{ynm})\n\nNotes\n\nIf object is a Partition, the group columns cannot be replaced.\n\n\n\n\n\n","category":"macro"},{"location":"splitapplycombine.html#GeoStatsBase.@combine","page":"Split-apply-combine","title":"GeoStatsBase.@combine","text":"@combine(object, :col‚ÇÅ = expr‚ÇÅ, :col‚ÇÇ = expr‚ÇÇ, ..., :col‚Çô = expr‚Çô)\n\nReturns a new data object with each column  :col‚ÇÅ, :col‚ÇÇ, ..., :col‚Çô being a reduction of object columns  defined by expressions expr‚ÇÅ, expr‚ÇÇ, ..., expr‚Çô.  The object can be a Data object or a Partition object  returned by the @groupby macro. In each expression the object columns  are represented by symbols and, in addition, strings or variables  can also be used with the {colname} syntax. If object is a Partition,  the reduction expressions will be applied in each subset of the Partition.\n\nSee also: @groupby.\n\nExamples\n\nusing Statistics\n\n@combine(data, :x_sum = sum(:x))\n@combine(data, :x_mean = mean(:x))\n\np = @groupby(data, :y)\n@combine(p, :x_prod = prod(:x))\n@combine(p, :x_median = median(:x))\n\n@combine(data, {\"z\"} = sum({\"x\"}) + prod({\"y\"}))\nxnm, ynm, znm = :x, :y, :z\n@combine(data, {znm} = sum({xnm}) + prod({ynm}))\n\n\n\n\n\n","category":"macro"},{"location":"solvers/builtin.html#Built-in","page":"Built-in","title":"Built-in","text":"","category":"section"},{"location":"solvers/builtin.html","page":"Built-in","title":"Built-in","text":"Below is the list of solvers that are readily available after loading the project.","category":"page"},{"location":"solvers/builtin.html#Estimation","page":"Built-in","title":"Estimation","text":"","category":"section"},{"location":"solvers/builtin.html","page":"Built-in","title":"Built-in","text":"IDW\nLWR\nKriging","category":"page"},{"location":"solvers/builtin.html#GeoStatsSolvers.IDW","page":"Built-in","title":"GeoStatsSolvers.IDW","text":"IDW(var‚ÇÅ=>param‚ÇÅ, var‚ÇÇ=>param‚ÇÇ, ...)\n\nInverse distance weighting estimation solver.\n\nParameters\n\nneighbors - Number of neighbors (default to all the data)\ndistance  - A distance defined in Distances.jl (default to Euclidean())\npower     - Power of the distances (default to 1)\n\nReferences\n\nShepard 1968. A two-dimensional interpolation function for irregularly-spaced data.\n\n\n\n\n\n\n\n","category":"type"},{"location":"solvers/builtin.html#GeoStatsSolvers.LWR","page":"Built-in","title":"GeoStatsSolvers.LWR","text":"LWR(var‚ÇÅ=>param‚ÇÅ, var‚ÇÇ=>param‚ÇÇ, ...)\n\nLocally weighted regression estimation solver.\n\nParameters\n\nneighbors - Number of neighbors (default to all the data)\ndistance  - A distance from Distances.jl (default to Euclidean())\nweightfun - Weighting function (default to exp(-3*h^2/2))\n\nReferences\n\nStone 1977. Consistent non-parametric regression.\nCleveland 1979. Robust locally weighted regression and smoothing scatterplots.\nCleveland & Grosse 1991. Computational methods for local regression.\n\n\n\n\n\n\n\n","category":"type"},{"location":"solvers/builtin.html#GeoStatsSolvers.Kriging","page":"Built-in","title":"GeoStatsSolvers.Kriging","text":"Kriging(var‚ÇÅ=>param‚ÇÅ, var‚ÇÇ=>param‚ÇÇ, ...)\n\nA polyalgorithm Kriging estimation solver.\n\nEach pair var=>param specifies the KrigingParam param for the Kriging variable var. In order to avoid boilerplate code, the constructor expects pairs of Symbol and NamedTuple instead.\n\nParameters\n\nvariogram - Variogram model (default to GaussianVariogram())\nmean      - Simple Kriging mean\ndegree    - Universal Kriging degree\ndrifts    - External Drift Kriging drift functions\n\nLatter options override former options. For example, by specifying drifts, the user is telling the algorithm to ignore degree and mean. If no option is specified, Ordinary Kriging is used by default with the variogram only.\n\nminneighbors - Minimum number of neighbors (default to 1)\nmaxneighbors - Maximum number of neighbors (default to nothing)\nneighborhood - Search neighborhood (default to nothing)\ndistance     - Distance used to find nearest neighbors (default to Euclidean())\n\nThe maxneighbors option can be used to perform approximate Kriging with a subset of data points per estimation location. If maxneighbors is set to nothing, global Kriging is performed. Two neighborhood search methods are available depending on the value of neighborhood:\n\nIf a neighborhood is provided, local Kriging is performed by sliding the neighborhood in the domain.\nIf neighborhood is not provided, the Kriging system is built using maxneighbors nearest neighbors according to a distance.\n\nExamples\n\nSolve the variable :var‚ÇÅ with Simple Kriging by specifying the mean, and the variable :var‚ÇÇ with Universal Kriging by specifying the degree and the variogram model.\n\njulia> Kriging(\n  :var‚ÇÅ => (mean=1.,),\n  :var‚ÇÇ => (degree=1, variogram=SphericalVariogram(range=20.))\n)\n\nSolve all variables of the problem with the default parameters (i.e. Ordinary Kriging with unit Gaussian variogram):\n\njulia> Kriging()\n\n\n\n\n\n\n\n","category":"type"},{"location":"solvers/builtin.html#Simulation","page":"Built-in","title":"Simulation","text":"","category":"section"},{"location":"solvers/builtin.html","page":"Built-in","title":"Built-in","text":"LUGS\nFFTGS\nSGS\nSPDEGS\nCookieCutter","category":"page"},{"location":"solvers/builtin.html#GeoStatsSolvers.LUGS","page":"Built-in","title":"GeoStatsSolvers.LUGS","text":"LUGS(var‚ÇÅ=>param‚ÇÅ, var‚ÇÇ=>param‚ÇÇ, ...)\n\nLU Gaussian simulation.\n\nParameters\n\nvariogram     - Theoretical variogram (default to GaussianVariogram())\nmean          - Mean of unconditional simulation (default to 0)\nmapping       - Data mapping method (default to NearestMapping())\nfactorization - Factorization method (default to cholesky)\n\nJoint parameters\n\ncorrelation - correlation coefficient between two covariates (default to 0).\n\nGlobal parameters\n\nrng - random number generator (default to Random.GLOBAL_RNG)\n\nExamples\n\nSimulate two variables var‚ÇÅ and var‚ÇÇ independently:\n\njulia> LUGS(:var‚ÇÅ => (variogram=SphericalVariogram(),mean=10.),\n            :var‚ÇÇ => (variogram=GaussianVariogram(),))\n\nSimulate two correlated variables var‚ÇÅ and var‚ÇÇ with correlation 0.7:\n\njulia> LUGS(:var‚ÇÅ => (variogram=SphericalVariogram(),mean=10.),\n            :var‚ÇÇ => (variogram=GaussianVariogram(),),\n            (:var‚ÇÅ,:var‚ÇÇ) => (correlation=0.7,))\n\nReferences\n\nAlabert 1987. The practice of fast conditional simulations through the LU decomposition of the covariance matrix\nOliver 2003. Gaussian cosimulation: modeling of the cross-covariance\n\n\n\n\n\n\n\n","category":"type"},{"location":"solvers/builtin.html#GeoStatsSolvers.FFTGS","page":"Built-in","title":"GeoStatsSolvers.FFTGS","text":"FFTGS(var‚ÇÅ=>param‚ÇÅ, var‚ÇÇ=>param‚ÇÇ, ...)\n\nFFT Gaussian simulation.\n\nParameters\n\nvariogram - theoretical variogram (default to GaussianVariogram())\nmean      - mean of Gaussian field (default to 0)\n\nIn the case of conditional simulation, the following parameters can be passed to the underlying Kriging solver:\n\nminneighbors - Minimum number of neighbors (default to 1)\nmaxneighbors - Maximum number of neighbors (default to 10)\nneighborhood - Search neighborhood (default to nothing)\ndistance     - Distance used to find nearest neighbors (default to Euclidean())\n\nGlobal parameters\n\nthreads - number of threads in FFT (default to all physical cores)\nrng - random number generator (default to Random.GLOBAL_RNG)\n\nReferences\n\nGutjahr 1997. General joint conditional simulations using a fast Fourier transform method\nG√≥mez-Hern√°ndez, J. & Srivastava, R. 2021. One Step at a Time: The Origins of Sequential Simulation and Beyond\n\n\n\n\n\n\n\n","category":"type"},{"location":"solvers/builtin.html#GeoStatsSolvers.SGS","page":"Built-in","title":"GeoStatsSolvers.SGS","text":"SGS(var‚ÇÅ=>param‚ÇÅ, var‚ÇÇ=>param‚ÇÇ, ...)\n\nSequential Gaussian simulation.\n\nParameters\n\nvariogram    - Variogram model (default to GaussianVariogram())\nmean         - mean for simple Kriging (default to 0.0)\npath         - Simulation path (default to LinearPath())\nminneighbors - Minimum number of neighbors (default to 1)\nmaxneighbors - Maximum number of neighbors (default to 10)\nneighborhood - Search neighborhood (default to nothing)\ndistance     - Distance used to find nearest neighbors (default to Euclidean())\nmapping      - Data mapping method (default to NearestMapping())\n\nFor each location in the simulation path, a maximum number of neighbors maxneighbors is used to fit a Gaussian distribution. The neighbors are searched according to a neighborhood.\n\nGlobal parameters\n\nrng - random number generator (default to Random.GLOBAL_RNG)\n\nReferences\n\nGomez-Hernandez & Journel 1993. Joint Sequential Simulation of MultiGaussian Fields\n\n\n\n\n\n\n\n","category":"type"},{"location":"solvers/builtin.html#GeoStatsSolvers.SPDEGS","page":"Built-in","title":"GeoStatsSolvers.SPDEGS","text":"SPDEGS(var‚ÇÅ=>param‚ÇÅ, var‚ÇÇ=>param‚ÇÇ, ...)\n\nSPDE Gaussian simulation.\n\nParameters\n\nsill  - Sill or total variance (default to 1.0)\nrange - Range or correlation length (default to 1.0)\n\nReferences\n\nLindgren et al. 2011. An explicit link between Gaussian fields and Gaussian Markov random fields: the stochastic partial differential equation approach\n\n\n\n\n\n\n\n","category":"type"},{"location":"solvers/builtin.html#GeoStatsSolvers.CookieCutter","page":"Built-in","title":"GeoStatsSolvers.CookieCutter","text":"CookieCutter(master, others)\n\nA cookie-cutter simulation solver.\n\nParameters\n\nmaster - Master simulation solver (a.k.a. facies solver)\nothers - Solvers for each value of the master realization\n\nExamples\n\nSimulate lithofacies with image quilting and fill porosity values with LU Gaussian simulation:\n\njulia> f  = IQ(:facies => (TI=IMG, template=(30,30,1)))\njulia> p‚ÇÄ = LUGS(:poro => (variogram=SphericalVariogram(range=10.),))\njulia> p‚ÇÅ = LUGS(:poro => (variogram=SphericalVariogram(range=20.),))\njulia> CookieCutter(f, Dict(0=>p‚ÇÄ, 1=>p‚ÇÅ))\n\n\n\n\n\n","category":"type"},{"location":"solvers/builtin.html#Learning","page":"Built-in","title":"Learning","text":"","category":"section"},{"location":"solvers/builtin.html","page":"Built-in","title":"Built-in","text":"PointwiseLearn","category":"page"},{"location":"solvers/builtin.html#GeoStatsSolvers.PointwiseLearn","page":"Built-in","title":"GeoStatsSolvers.PointwiseLearn","text":"PointwiseLearn(model)\n\nA learning solver that converts geospatial data to a tabular format with features (and possibly labels) for each point, and then solves the problem with classical statistical learning model.\n\nParameters\n\nmodel - Learning model implementing the MLJModelInterface.jl.\n\nReferences\n\nHoffimann et al. 2020. Geostatistical Learning: Challenges and Opportunities\n\n\n\n\n\n","category":"type"},{"location":"resources/publications.html#Publications","page":"Publications","title":"Publications","text":"","category":"section"},{"location":"resources/publications.html","page":"Publications","title":"Publications","text":"Below is a list of publications made possible with this project:","category":"page"},{"location":"resources/publications.html","page":"Publications","title":"Publications","text":"Karsanina, M. & Gerke, K. 2022. Stochastic (re)constructions of non-stationary material structures: Using ensemble averaged correlation functions and non-uniform phase distributions\nSep√∫lveda et al. 2022. Evaluation of multivariate Gaussian transforms for geostatistical applications\nHoffimann et al. 2022. Modeling Geospatial Uncertainty of Geometallurgical Variables with Bayesian Models and Hilbert-Kriging\nHoffimann et al. 2021. Geostatistical Learning: Challenges and Opportunities\nAsner et al. 2021. Abiotic and Human Drivers of Reef Habitat Complexity Throughout the Main Hawaiian Islands\nAsner et al. 2020. Large-scale mapping of live corals to guide reef conservation\nHoffimann, J. & Zadrozny, B. 2019. Efficient Variography with Partition Variograms\nHoffimann et al. 2019. Morphodynamic Analysis and Statistical Synthesis of Geomorphic Data: Application to a Flume Experiment\nBarfod et al. 2017. Hydrostratigraphic Modeling using Multiple-point Statistics and Airbone Transient Electromagnetic Methods\nHoffimann et al. 2017. Stochastic Simulation by Image Quilting of Process-based Geological Models","category":"page"},{"location":"transforms.html#Table-transforms","page":"Table transforms","title":"Table transforms","text":"","category":"section"},{"location":"transforms.html","page":"Table transforms","title":"Table transforms","text":"TableTranfrorms.jl provides a very powerful list of transforms that were designed to work seamlessly with geospatial data. Other packages such as CoDa.jl provide additional transforms for custom variable types.","category":"page"},{"location":"transforms.html#Overview","page":"Table transforms","title":"Overview","text":"","category":"section"},{"location":"transforms.html","page":"Table transforms","title":"Table transforms","text":"The list of supported transforms is continuously growing. The following code can be used to print an updated list in any project environment:","category":"page"},{"location":"transforms.html","page":"Table transforms","title":"Table transforms","text":"# packages to print type tree\nusing InteractiveUtils\nusing AbstractTrees\nusing TransformsBase\n\n# packages with transforms\nusing GeoStats\nusing CoDa\n\n# define the tree of types\nAbstractTrees.children(T::Type) = subtypes(T)\n\n# print all currently available transforms\nAbstractTrees.print_tree(TransformsBase.Transform)","category":"page"},{"location":"transforms.html","page":"Table transforms","title":"Table transforms","text":"Transforms at the leaves of the tree above should have a docstring with more information on the available options. For example, the documentation of the Select transform is shown below:","category":"page"},{"location":"transforms.html","page":"Table transforms","title":"Table transforms","text":"Select","category":"page"},{"location":"transforms.html#TableTransforms.Select","page":"Table transforms","title":"TableTransforms.Select","text":"Select(col‚ÇÅ, col‚ÇÇ, ..., col‚Çô)\nSelect([col‚ÇÅ, col‚ÇÇ, ..., col‚Çô])\nSelect((col‚ÇÅ, col‚ÇÇ, ..., col‚Çô))\n\nThe transform that selects columns col‚ÇÅ, col‚ÇÇ, ..., col‚Çô.\n\nSelect(col‚ÇÅ => newcol‚ÇÅ, col‚ÇÇ => newcol‚ÇÇ, ..., col‚Çô => newcol‚Çô)\n\nSelects the columns col‚ÇÅ, col‚ÇÇ, ..., col‚Çô and rename them to newcol‚ÇÅ, newcol‚ÇÇ, ..., newcol‚Çô.\n\nSelect(regex)\n\nSelects the columns that match with regex.\n\nExamples\n\nSelect(1, 3, 5)\nSelect([:a, :c, :e])\nSelect((\"a\", \"c\", \"e\"))\nSelect(1 => :x, 3 => :y)\nSelect(:a => :x, :b => :y)\nSelect(\"a\" => \"x\", \"b\" => \"y\")\nSelect(r\"[ace]\")\n\n\n\n\n\n","category":"type"},{"location":"transforms.html","page":"Table transforms","title":"Table transforms","text":"Transforms of type GeometricTransform operate on the underlying geospatial domain, whereas transforms of type FeatureTransform operate on the attribute table:","category":"page"},{"location":"transforms.html","page":"Table transforms","title":"Table transforms","text":"Meshes.GeometricTransform\nTableTransforms.FeatureTransform","category":"page"},{"location":"transforms.html#Meshes.GeometricTransform","page":"Table transforms","title":"Meshes.GeometricTransform","text":"GeometricTransform\n\nA method to transform the geometry (e.g. coordinates) of objects. See https://en.wikipedia.org/wiki/Geometric_transformation.\n\n\n\n\n\n","category":"type"},{"location":"transforms.html#TableTransforms.FeatureTransform","page":"Table transforms","title":"TableTransforms.FeatureTransform","text":"FeatureTransform\n\nA transform that operates on the columns of the table containing features, i.e., simple attributes such as numbers, strings, etc.\n\n\n\n\n\n","category":"type"},{"location":"transforms.html","page":"Table transforms","title":"Table transforms","text":"Other transforms such as Detrend are are defined in terms of both the geospatial domain and the attribute table:","category":"page"},{"location":"transforms.html","page":"Table transforms","title":"Table transforms","text":"Detrend","category":"page"},{"location":"transforms.html#GeoStatsBase.Detrend","page":"Table transforms","title":"GeoStatsBase.Detrend","text":"Detrend(col‚ÇÅ, col‚ÇÇ, ..., col‚Çô; degree=1)\nDetrend([col‚ÇÅ, col‚ÇÇ, ..., col‚Çô]; degree=1)\nDetrend((col‚ÇÅ, col‚ÇÇ, ..., col‚Çô); degree=1)\n\nThe transform that detrends columns col‚ÇÅ, col‚ÇÇ, ..., col‚Çô with a polynomial of given degree.\n\nDetrend(regex; degree=1)\n\nDetrends the columns that match with regex.\n\nExamples\n\nDetrend(1, 3, 5)\nDetrend([:a, :c, :e])\nDetrend((\"a\", \"c\", \"e\"))\nDetrend(r\"[ace]\", degree=2)\nDetrend(:)\n\nSee also trend.\n\n\n\n\n\n","category":"type"},{"location":"transforms.html","page":"Table transforms","title":"Table transforms","text":"All transforms and pipelines implement the following functions:","category":"page"},{"location":"transforms.html","page":"Table transforms","title":"Table transforms","text":"TableTransforms.isrevertible\nTableTransforms.apply\nTableTransforms.revert\nTableTransforms.reapply","category":"page"},{"location":"transforms.html#TransformsBase.isrevertible","page":"Table transforms","title":"TransformsBase.isrevertible","text":"isrevertible(transform)\n\nTells whether or not the transform is revertible, i.e. supports a revert function. Defaults to false for new transform types.\n\n\n\n\n\n","category":"function"},{"location":"transforms.html#TransformsBase.apply","page":"Table transforms","title":"TransformsBase.apply","text":"newobject, cache = apply(transform, object)\n\nApply transform on the object. Return the newobject and a cache to revert the transform later.\n\n\n\n\n\n","category":"function"},{"location":"transforms.html#TransformsBase.revert","page":"Table transforms","title":"TransformsBase.revert","text":"object = revert(transform, newobject, cache)\n\nRevert the transform on the newobject using the cache from the corresponding apply call and return the original object. Only defined when the transform isrevertible.\n\n\n\n\n\n","category":"function"},{"location":"transforms.html#TransformsBase.reapply","page":"Table transforms","title":"TransformsBase.reapply","text":"newobject = reapply(transform, object, cache)\n\nReapply the transform to (a possibly different) object using a cache that was created with a previous apply call.\n\n\n\n\n\n","category":"function"},{"location":"transforms.html#Examples","page":"Table transforms","title":"Examples","text":"","category":"section"},{"location":"transforms.html","page":"Table transforms","title":"Table transforms","text":"Consider the following geospatial data:","category":"page"},{"location":"transforms.html","page":"Table transforms","title":"Table transforms","text":"using GeoStats\nusing DataFrames\n\ntab = DataFrame(a=rand(1000), b=randn(1000), c=rand(1000))\ndom = CartesianGrid(100, 100)\n\nŒ© = georef(tab, dom)\n\ndescribe(values(Œ©))","category":"page"},{"location":"transforms.html","page":"Table transforms","title":"Table transforms","text":"We can create a pipeline that transforms the varialbes :a and :c to their normal quantile (or scores):","category":"page"},{"location":"transforms.html","page":"Table transforms","title":"Table transforms","text":"pipe = Select(:a, :c) ‚Üí Quantile()\n\nŒ©ÃÑ, cache = apply(pipe, Œ©)\n\ndescribe(values(Œ©ÃÑ))","category":"page"},{"location":"transforms.html","page":"Table transforms","title":"Table transforms","text":"We can then revert the transform given any new geospatial data in the transformed sample space:","category":"page"},{"location":"transforms.html","page":"Table transforms","title":"Table transforms","text":"Œ©‚Çí = revert(pipe, Œ©ÃÑ, cache)\n\ndescribe(values(Œ©‚Çí))","category":"page"},{"location":"solvers/overview.html#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"solvers/overview.html","page":"Overview","title":"Overview","text":"Below is a list of currently available geostatistical solvers. Some of these solvers are distributed with GeoStats.jl, a.k.a. \"built-in\" solvers, whereas other solvers are available in separate packages, a.k.a. \"external\" solvers. If your solver is not listed below, please submit a pull request and we will be happy to review and add it to the list.","category":"page"},{"location":"solvers/overview.html","page":"Overview","title":"Overview","text":"Solvers are organized into three categories: estimation, simulation and learning. These categories correspond to the Problems defined in the framework.","category":"page"},{"location":"solvers/overview.html","page":"Overview","title":"Overview","text":"All simulation solvers below can generate realizations in parallel on a cluster of computers unless otherwise noted. Please check the documentation of solve for more details:","category":"page"},{"location":"solvers/overview.html","page":"Overview","title":"Overview","text":"solve(::SimulationProblem, ::SimulationSolver)\nsolvesingle","category":"page"},{"location":"solvers/overview.html#GeoStatsBase.solve-Tuple{SimulationProblem, SimulationSolver}","page":"Overview","title":"GeoStatsBase.solve","text":"solve(problem, solver; procs=[myid()])\n\nSolve the simulation problem with the simulation solver, optionally using multiple processes procs.\n\nNotes\n\nDefault implementation calls solvesingle in parallel.\n\n\n\n\n\n","category":"method"},{"location":"solvers/overview.html#GeoStatsBase.solvesingle","page":"Overview","title":"GeoStatsBase.solvesingle","text":"solvesingle(problem, covariables, solver, preproc)\n\nSolve a single realization of covariables in the simulation problem with the simulation solver, optionally using preprocessed data in preproc.\n\nNotes\n\nBy implementing this function instead of solve, the developer is informing the framework that realizations generated with his/her solver are indenpendent one from another. GeoStats.jl will trigger the algorithm in parallel (if enough processes are available).\n\n\n\n\n\n","category":"function"},{"location":"solvers/overview.html#Estimation","page":"Overview","title":"Estimation","text":"","category":"section"},{"location":"solvers/overview.html","page":"Overview","title":"Overview","text":"Solver Description References\nKriging Kriging (SK, OK, UK, EDK) Matheron 1971\nIDW Inverse distance weighting Shepard 1968\nLWR Locally weighted regression Cleveland 1979","category":"page"},{"location":"solvers/overview.html#Simulation","page":"Overview","title":"Simulation","text":"","category":"section"},{"location":"solvers/overview.html#Gaussian","page":"Overview","title":"Gaussian","text":"","category":"section"},{"location":"solvers/overview.html","page":"Overview","title":"Overview","text":"Solver Description References\nLUGS LU Gaussian simulation Alabert 1987\nSGS Sequential Gaussian simulation G√≥mez-Hern√°ndez 1993\nFFTGS FFT Gaussian simulation Gutjahr 1997\nSPDEGS SPDE Gaussian simulation Lindgren 2011","category":"page"},{"location":"solvers/overview.html#Non-Gaussian","page":"Overview","title":"Non-Gaussian","text":"","category":"section"},{"location":"solvers/overview.html","page":"Overview","title":"Overview","text":"Solver Description References\nIQ Image quilting Hoffimann 2017\nTPS Turing patterns Turing 1952","category":"page"},{"location":"solvers/overview.html#Meta","page":"Overview","title":"Meta","text":"","category":"section"},{"location":"solvers/overview.html","page":"Overview","title":"Overview","text":"Solver Description References\nStratSim Stratigraphy simulation Hoffimann 2018\nCookieCutter Cookie-cutter simulation Begg 1992","category":"page"},{"location":"solvers/overview.html#Learning","page":"Overview","title":"Learning","text":"","category":"section"},{"location":"solvers/overview.html","page":"Overview","title":"Overview","text":"Solver Description References\nPointwiseLearn Pointwise learning Hoffimann 2018","category":"page"},{"location":"weighting.html#Weighting","page":"Weighting","title":"Weighting","text":"","category":"section"},{"location":"weighting.html","page":"Weighting","title":"Weighting","text":"Geostatistical weighting is the process of assigning weights to geospatial data using the geospatial coordinates of the samples. Obtained weights are often used for declustering and importance sampling.","category":"page"},{"location":"weighting.html","page":"Weighting","title":"Weighting","text":"weight\nWeightingMethod\nBlockWeighting\nDensityRatioWeighting","category":"page"},{"location":"weighting.html#GeoStatsBase.weight","page":"Weighting","title":"GeoStatsBase.weight","text":"weight(object, method)\n\nWeight spatial object with method.\n\n\n\n\n\n","category":"function"},{"location":"weighting.html#GeoStatsBase.WeightingMethod","page":"Weighting","title":"GeoStatsBase.WeightingMethod","text":"WeightingMethod\n\nA method to weight spatial data.\n\n\n\n\n\n","category":"type"},{"location":"weighting.html#GeoStatsBase.BlockWeighting","page":"Weighting","title":"GeoStatsBase.BlockWeighting","text":"BlockWeighting(sides)\nBlockWeighting(side‚ÇÅ, side‚ÇÇ, ...)\n\nA weighting method that assigns weights to points in spatial object based on blocks of given sides. The number n of points inside a block determines the weights 1/n of these points.\n\n\n\n\n\n","category":"type"},{"location":"weighting.html#GeoStatsBase.DensityRatioWeighting","page":"Weighting","title":"GeoStatsBase.DensityRatioWeighting","text":"DensityRatioWeighting(tdata, [vars]; [options])\n\nDensity ratio weights based on empirical distribution of variables in target data tdata. Default to all variables.\n\nOptional parameters\n\nestimator - Density ratio estimator (default to LSIF())\noptlib    - Optimization library (default to default_optlib(estimator))\n\nNotes\n\nEstimators from DensityRatioEstimation.jl are supported.\n\n\n\n\n\n","category":"type"},{"location":"contributing/guidelines.html#Guidelines","page":"Guidelines","title":"Guidelines","text":"","category":"section"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"First off, thank you for considering contributing to GeoStats.jl. It‚Äôs people like you that make this project so much fun. Below are a few suggestions to speed up the collaboration process:","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"Please be polite, we are here to help and learn from each other.\nTry to explain your contribution with simple language.\nReferences to textbooks and papers are always welcome.\nFollow the coding standards in the source.","category":"page"},{"location":"contributing/guidelines.html#How-to-start-contributing?","page":"Guidelines","title":"How to start contributing?","text":"","category":"section"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"Contributing to an open-source project for the very first time can be a very daunting task. To make the process easier and more GitHub-beginner-friendly, the community has written an article about how to start contributing to open-source and overcome the mental and technical barriers that come associated with it. The article will also take you through the steps required to make your first contribution in detail.","category":"page"},{"location":"contributing/guidelines.html#Reporting-issues","page":"Guidelines","title":"Reporting issues","text":"","category":"section"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"If you are experiencing issues or have discovered a bug, please report it on GitHub. To make the resolution process easier, please include the version of Julia and GeoStats.jl in your writeup. These can be found with two commands:","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"julia> versioninfo()\njulia> using Pkg; Pkg.status()","category":"page"},{"location":"contributing/guidelines.html#Feature-requests","page":"Guidelines","title":"Feature requests","text":"","category":"section"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"If you have suggestions of improvement or algorithms that you would like to see implemented in GeoStats.jl, please open an issue on GitHub. Suggestions as well as feature requests are very welcome.","category":"page"},{"location":"contributing/guidelines.html#Code-contribution","page":"Guidelines","title":"Code contribution","text":"","category":"section"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"If you have code that you would like to contribute to GeoStats.jl, that is awesome! Please open an issue before you create the pull request on GitHub so that we make sure your idea is aligned with our goals for the project.","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"After your idea is discussed and revised by maintainers, please get the development version of the project by typing the following in the package manager:","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"] activate @geo","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"This will create a fresh environment called @geo where you can play with the project components without compromising your normal user environment. Next, go ahead and type:","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"] dev GeoStatsBase\n] dev Variography\n] dev KrigingEstimators\n] dev PointPatterns\n] dev GeoClustering\n] dev GeoStatsSolvers\n] dev GeoStats","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"to clone all the project components in your ~/.julia folder. You can modify the source code and submit a pull request on GitHub later.","category":"page"},{"location":"clustering.html#Clustering","page":"Clustering","title":"Clustering","text":"","category":"section"},{"location":"clustering.html","page":"Clustering","title":"Clustering","text":"Unlike traditional clustering algorithms in machine learning, geostatistical clustering (a.k.a. domaining) algorithms consider both the features and the geospatial coordinates of the data.","category":"page"},{"location":"clustering.html","page":"Clustering","title":"Clustering","text":"Consider the following data as an example:","category":"page"},{"location":"clustering.html","page":"Clustering","title":"Clustering","text":"using GeoStats # hide\nusing Plots # hide\nusing GeoStatsPlots # hide\ngr(format=:png) # hide\n\nŒ© = georef((Z=[10sin(i/10) + j for i in 1:2:100, j in 1:2:100],))\n\nplot(Œ©)","category":"page"},{"location":"clustering.html","page":"Clustering","title":"Clustering","text":"We can cluster the data with traditional clustering models from MLJ.jl:","category":"page"},{"location":"clustering.html","page":"Clustering","title":"Clustering","text":"using MLJ\n\nkmeans = MLJ.@load KMeans pkg=Clustering\n\nC = cluster(Œ©, kmeans(k=50))\n\nplot(C)","category":"page"},{"location":"clustering.html","page":"Clustering","title":"Clustering","text":"but there is no guarantee that the clusters will consist of contiguous volumes in space. Alternatively, we can use the following geostatistical models:","category":"page"},{"location":"clustering.html#GHC","page":"Clustering","title":"GHC","text":"","category":"section"},{"location":"clustering.html","page":"Clustering","title":"Clustering","text":"GHC","category":"page"},{"location":"clustering.html#GeoClustering.GHC","page":"Clustering","title":"GeoClustering.GHC","text":"GHC(k, Œª; kern=:epanechnikov, link=:ward)\n\nA method for partitioning geospatial data into k clusters  according to a range Œª using Geostatistical Hierarchical Clustering (GHC). The larger the range the more connected are nearby samples.\n\nParameters\n\nk    - Approximate number of clusters\nŒª    - Approximate range of kernel function\nkern - Kernel function (:uniform, :triangular or :epanechnikov)\nlink - Linkage function (:single, :average, :complete, :ward or :ward_presquared)\n\nReferences\n\nFouedjio, F. 2016. A hierarchical clustering method for multivariate geostatistical data\n\nNotes\n\nThe range parameter controls the sparsity pattern of the pairwise distances, which can greatly affect the computational performance of the GHC algorithm. We recommend choosing a range that is small enough to connect nearby samples. For example, clustering data over a 100x100 Cartesian grid with unit spacing is possible with Œª=1.0 or Œª=2.0 but the problem starts to become computationally unfeasible around Œª=10.0 due to the density of points.\n\n\n\n\n\n","category":"type"},{"location":"clustering.html","page":"Clustering","title":"Clustering","text":"C = cluster(Œ©, GHC(20, 1.0))\n\nplot(C)","category":"page"},{"location":"clustering.html#GSC","page":"Clustering","title":"GSC","text":"","category":"section"},{"location":"clustering.html","page":"Clustering","title":"Clustering","text":"GSC","category":"page"},{"location":"clustering.html#GeoClustering.GSC","page":"Clustering","title":"GeoClustering.GSC","text":"GSC(k, m; œÉ=1.0, tol=1e-4, maxiter=10, weights=nothing)\n\nA method for partitioning geospatial data into k clusters using Geostatistical Spectral Clustering (GSC).\n\nParameters\n\nk       - Desired number of clusters\nm       - Multiplicative factor for adjacent weights\nœÉ       - Standard deviation for exponential model (default to 1.0)\ntol     - Tolerance of k-means algorithm (default to 1e-4)\nmaxiter - Maximum number of iterations (default to 10)\nweights - Dictionary with weights for each attribute (default to nothing)\n\nReferences\n\nRomary et al. 2015. Unsupervised classification of multivariate geostatistical data: Two algorithms\n\nNotes\n\nThe algorithm implemented here is slightly different than the algorithm\n\ndescribed in Romary et al. 2015. Instead of setting W·µ¢‚±º = 0 when i <-/-> j, we simply magnify the weight by a multiplicative factor W·µ¢‚±º *= m when i <‚Äì> j. This leads to dense matrices but also better results in practice.\n\n\n\n\n\n","category":"type"},{"location":"clustering.html","page":"Clustering","title":"Clustering","text":"C = cluster(Œ©, GSC(50, 2.0))\n\nplot(C)","category":"page"},{"location":"clustering.html#SLIC","page":"Clustering","title":"SLIC","text":"","category":"section"},{"location":"clustering.html","page":"Clustering","title":"Clustering","text":"SLIC","category":"page"},{"location":"clustering.html#GeoClustering.SLIC","page":"Clustering","title":"GeoClustering.SLIC","text":"SLIC(k, m; tol=1e-4, maxiter=10)\n\nA method for clustering geospatial data into approximately k clusters using Simple Linear Iterative Clustering (SLIC). The method produces clusters of samples that are spatially connected based on a distance d‚Çõ and that, at the same time, are similar in terms of vars with distance d·µ•. The tradeoff is controlled with a hyperparameter parameter m in an additive model d‚Çú = ‚àö(d·µ•¬≤ + m¬≤(d‚Çõ/s)¬≤).\n\nParameters\n\nk       - Approximate number of clusters\nm       - Hyperparameter of SLIC model\ntol     - Tolerance of k-means algorithm (default to 1e-4)\nmaxiter - Maximum number of iterations (default to 10)\nweights - Dictionary with weights for each attribute (default to nothing)\n\nReferences\n\nAchanta et al. 2011. SLIC superpixels compared to state-of-the-art superpixel methods\n\n\n\n\n\n","category":"type"},{"location":"clustering.html","page":"Clustering","title":"Clustering","text":"C = cluster(Œ©, SLIC(50, 0.01))\n\nplot(C)","category":"page"},{"location":"declustering.html#Declustering","page":"Declustering","title":"Declustering","text":"","category":"section"},{"location":"declustering.html","page":"Declustering","title":"Declustering","text":"Declustered statistics are statistics that make use of geospatial coordinates in an attempt to correct potential sampling bias:","category":"page"},{"location":"declustering.html","page":"Declustering","title":"Declustering","text":"<p align=\"center\">\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/zAP-36Yh5sg\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</p>","category":"page"},{"location":"declustering.html","page":"Declustering","title":"Declustering","text":"The following statistics have geospatial semantics:","category":"page"},{"location":"declustering.html","page":"Declustering","title":"Declustering","text":"mean(::Data)\nvar(::Data)\nquantile(::Data, ::Any)","category":"page"},{"location":"declustering.html#Statistics.mean-Tuple{Data}","page":"Declustering","title":"Statistics.mean","text":"mean(data)\nmean(data, v)\nmean(data, v, s)\n\nDeclustered mean of geospatial data. Optionally, specify the variable v and the block side s.\n\n\n\n\n\n","category":"method"},{"location":"declustering.html#Statistics.var-Tuple{Data}","page":"Declustering","title":"Statistics.var","text":"var(data)\nvar(data, v)\nvar(data, v, s)\n\nDeclustered variance of geospatial data. Optionally, specify the variable v and the block side s.\n\n\n\n\n\n","category":"method"},{"location":"declustering.html#Statistics.quantile-Tuple{Data, Any}","page":"Declustering","title":"Statistics.quantile","text":"quantile(data, p)\nquantile(data, v, p)\nquantile(data, v, p, s)\n\nDeclustered quantile of geospatial data at probability p. Optionally, specify the variable v and the block side s.\n\n\n\n\n\n","category":"method"},{"location":"declustering.html","page":"Declustering","title":"Declustering","text":"A histogram with geospatial semantics is also available where the heights of the bins are adjusted based on the coordinates of the samples:","category":"page"},{"location":"declustering.html","page":"Declustering","title":"Declustering","text":"EmpiricalHistogram","category":"page"},{"location":"declustering.html#GeoStatsBase.EmpiricalHistogram","page":"Declustering","title":"GeoStatsBase.EmpiricalHistogram","text":"EmpiricalHistogram(sdata, var, [s]; kwargs...)\n\nSpatial histogram of variable var in spatial data sdata. Optionally, specify the block side s and the keyword arguments kwargs for the fit(Histogram, ...) call.\n\n\n\n\n\n","category":"type"},{"location":"variography/fitting.html#Fitting-variograms","page":"Fitting variograms","title":"Fitting variograms","text":"","category":"section"},{"location":"variography/fitting.html#Overview","page":"Fitting variograms","title":"Overview","text":"","category":"section"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"Fitting theoretical variograms to empirical observations is an important modeling step to ensure valid mathematical models of spatial continuity. Given an empirical variogram, the fit function can be used to perform the fit:","category":"page"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"fit(::Type{Variogram}, ::EmpiricalVariogram, ::VariogramFitAlgo)","category":"page"},{"location":"variography/fitting.html#StatsAPI.fit-Tuple{Type{Variogram}, EmpiricalVariogram, VariogramFitAlgo}","page":"Fitting variograms","title":"StatsAPI.fit","text":"fit(V, Œ≥, [algo])\nfit(V, Œ≥, [weigthfun])\n\nFit theoretical variogram type V to empirical variogram Œ≥ using algorithm algo. Default algorithm is WeightedLeastSquares.\n\nAlternatively pass the weighting function weightfun directly to the fitting procedure.\n\n\n\n\n\nfit(Variogram, Œ≥, [algo])\nfit(Variogram, Œ≥, [weightfun])\n\nFit all subtypes of Variogram to empirical variogram Œ≥ and return the one with minimum error as defined by the algorithm algo.\n\nAlternatively pass the weighting function weightfun directly to the fitting procedure.\n\n\n\n\n\n","category":"method"},{"location":"variography/fitting.html#Example","page":"Fitting variograms","title":"Example","text":"","category":"section"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"using GeoStats # hide\nusing Plots # hide\nusing GeoStatsPlots # hide\ngr(size=(800,400)) # hide\n\n# sinusoidal data\nùíü = georef((Z=[sin(i/2) + sin(j/2) for i in 1:50, j in 1:50],))\n\n# empirical variogram\ng = EmpiricalVariogram(ùíü, :Z, maxlag=25.)\n\nplot(g)","category":"page"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"We can fit specific models to the empirical variogram:","category":"page"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"Œ≥ = fit(SineHoleVariogram, g)\n\nplot(g); plot!(Œ≥)","category":"page"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"or let GeoStats.jl find the model with minimum error:","category":"page"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"Œ≥ = fit(Variogram, g)\n\nplot(g); plot!(Œ≥)","category":"page"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"which should be a SineHoleVariogram given that the synthetic data of this example is sinusoidal.","category":"page"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"Optionally, we can specify a weighting function to give different weights to the lags:","category":"page"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"Œ≥ = fit(SineHoleVariogram, g, h -> exp(-h))\n\nplot(g); plot!(Œ≥)","category":"page"},{"location":"variography/fitting.html#Methods","page":"Fitting variograms","title":"Methods","text":"","category":"section"},{"location":"variography/fitting.html#Weighted-least-squares","page":"Fitting variograms","title":"Weighted least squares","text":"","category":"section"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"WeightedLeastSquares","category":"page"},{"location":"variography/fitting.html#Variography.WeightedLeastSquares","page":"Fitting variograms","title":"Variography.WeightedLeastSquares","text":"WeightedLeastSquares()\nWeightedLeastSquares(w)\n\nFit theoretical variogram using weighted least squares with weighting function w (e.g. h -> 1/h). If no weighting function is provided, bin counts of empirical variogram are normalized and used as weights.\n\n\n\n\n\n","category":"type"},{"location":"miscellaneous.html#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"Below is a list of miscellaneous geospatial operations.","category":"page"},{"location":"miscellaneous.html#Split","page":"Miscellaneous","title":"Split","text":"","category":"section"},{"location":"miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"using GeoStats\nusing GeoStatsImages\nusing Plots # hide\nusing GeoStatsPlots # hide\ngr(format=:png) # hide\n\nùíü = geostatsimage(\"Strebelle\")\n\n# 50/50 split perpendicular to (1.,1.)\nS = split(ùíü, 0.5, (1.,1.))\n\nplot(plot(S[1],ms=0.2), plot(S[2],ms=0.2))","category":"page"},{"location":"miscellaneous.html#Slice","page":"Miscellaneous","title":"Slice","text":"","category":"section"},{"location":"miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"Meshes.slice","category":"page"},{"location":"miscellaneous.html#Meshes.slice","page":"Miscellaneous","title":"Meshes.slice","text":"slice(object, xmin:xmax, ymin:ymax, ...)\n\nSlice the object using real coordinate ranges xmin:xmax, ymin:ymax, ...\n\nNotes\n\nThis function is equivalent to view(object, Box(first.(ranges), last.(ranges)).\n\nIn Julia the range 0.5:10.0 is materialized as [0.5, ..., 9.5] so it won't necessarily include the right value. This behavior is different than the more intuitive behavior of view(object, Box((0.5,0.5), (10.0,10.0)).\n\n\n\n\n\n","category":"function"},{"location":"miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"using GeoStats # hide\nusing GeoStatsImages # hide\nusing Plots # hide\nusing GeoStatsPlots # hide\ngr(format=:png) # hide\n\n# slice image\nI = geostatsimage(\"Strebelle\")\nS = slice(I, 50.5:100.2, 41.7:81.3)\n\np1 = plot(plot(I), plot(S), link=:both)\n\n# slide point set\nP = sample(I, 100)\nS = slice(P, 50.5:150.7, 175.2:250.3)\n\np2 = plot(plot(P), plot(S), link=:both, ms=3)\n\nplot(p1, p2, layout=(2,1))","category":"page"},{"location":"miscellaneous.html#Unique","page":"Miscellaneous","title":"Unique","text":"","category":"section"},{"location":"miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"uniquecoords","category":"page"},{"location":"miscellaneous.html#GeoStatsBase.uniquecoords","page":"Miscellaneous","title":"GeoStatsBase.uniquecoords","text":"uniquecoords(data, agg=Dict())\n\nRetain locations in data with unique coordinates.\n\nDuplicates of a variable var are aggregated with aggregation function agg[var]. Default aggregation function is mean for continuous variables and first otherwise.\n\n\n\n\n\n","category":"function"},{"location":"miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"using GeoStats # hide\nusing Tables # hide\n\nD = georef((z=[0, 1, 0],), [(0.,0.), (1.,0.), (0.,0.)])\n\nU = uniquecoords(D)\n\nTables.rows(U)","category":"page"},{"location":"miscellaneous.html#Trend","page":"Miscellaneous","title":"Trend","text":"","category":"section"},{"location":"miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"trend","category":"page"},{"location":"miscellaneous.html#GeoStatsBase.trend","page":"Miscellaneous","title":"GeoStatsBase.trend","text":"trend(data, vars; degree=1)\n\nReturn the deterministic spatial trend for the variables vars in the spatial data. Approximate the trend with a polynomial of given degree.\n\nReferences\n\nMenafoglio, A., Secchi, P. 2013. A Universal Kriging predictor for spatially dependent functional data of a Hilbert Space\n\n\n\n\n\n","category":"function"},{"location":"miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"using GeoStats # hide\nusing Plots # hide\nusing GeoStatsPlots # hide\n\n# quadratic + noise\nr = range(-1,stop=1,length=100)\nŒº = [x^2 + y^2 for x in r, y in r]\nœµ = 0.1rand(100,100)\nùíü = georef((z=Œº+œµ,))\n\n‚Ñ≥ = trend(ùíü, :z, degree=2)\n\nplot(plot(ùíü), plot(‚Ñ≥))","category":"page"},{"location":"miscellaneous.html#Integrate","page":"Miscellaneous","title":"Integrate","text":"","category":"section"},{"location":"miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"integrate(::Data, ::Symbol)","category":"page"},{"location":"miscellaneous.html#GeoStatsBase.integrate-Tuple{Data, Symbol}","page":"Miscellaneous","title":"GeoStatsBase.integrate","text":"integrate(data, var; rank=nothing)\n\nIntegrate data for variable var over geometries of given rank. Default rank is the parametric dimension of the underlying domain where the data is georeferenced.\n\n\n\n\n\n","category":"method"},{"location":"problems.html#Problems","page":"Problems","title":"Problems","text":"","category":"section"},{"location":"problems.html","page":"Problems","title":"Problems","text":"The project provides solutions to three types of geostatistical problems. These problems can be defined unambiguously and independently of solvers, which is quite convenient for fair comparison of alternative workflows.","category":"page"},{"location":"problems.html#Estimation","page":"Problems","title":"Estimation","text":"","category":"section"},{"location":"problems.html","page":"Problems","title":"Problems","text":"EstimationProblem","category":"page"},{"location":"problems.html#GeoStatsBase.EstimationProblem","page":"Problems","title":"GeoStatsBase.EstimationProblem","text":"EstimationProblem(sdata, sdomain, vars)\n\nA spatial estimation problem on a given spatial domain sdomain in which the variables to be estimated are listed in vars. The data of the problem is stored in spatial data sdata.\n\nExamples\n\nCreate an estimation problem for precipitation measurements:\n\njulia> EstimationProblem(sdata, sdomain, :precipitation)\n\nCreate an estimation problem for precipitation and CO‚ÇÇ:\n\njulia> EstimationProblem(sdata, sdomain, (:precipitation,:CO‚ÇÇ))\n\n\n\n\n\n","category":"type"},{"location":"problems.html#Example","page":"Problems","title":"Example","text":"","category":"section"},{"location":"problems.html","page":"Problems","title":"Problems","text":"Define a 2D estimation problem:","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"using GeoStats # hide\nusing Plots # hide\nusing GeoStatsPlots # hide\ngr(size=(900,400),clabels=true) # hide\n\n# list of properties with coordinates\nprops = (Z=[1.,0.,1.],)\ncoord = [(25.,25.), (50.,75.), (75.,50.)]\n\n# estimation problem\nùíü = georef(props, coord)\nùí¢ = CartesianGrid(100, 100)\nùí´ = EstimationProblem(ùíü, ùí¢, :Z)","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"Solve the problem with a few built-in solvers:","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"# few built-in solvers\nS1 = IDW(:Z => (distance=Euclidean(),))\nS2 = IDW(:Z => (distance=Chebyshev(),))\nS3 = Kriging(:Z => (variogram=GaussianVariogram(range=35.),))\n\n# solve the problem\nsol = [solve(ùí´, S) for S in (S1, S2, S3)]\n\n# plot the solution\ncontourf(sol[1])","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"contourf(sol[2])","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"contourf(sol[3])","category":"page"},{"location":"problems.html#Simulation","page":"Problems","title":"Simulation","text":"","category":"section"},{"location":"problems.html","page":"Problems","title":"Problems","text":"SimulationProblem","category":"page"},{"location":"problems.html#GeoStatsBase.SimulationProblem","page":"Problems","title":"GeoStatsBase.SimulationProblem","text":"SimulationProblem(sdata, sdomain, vars, nreals)\nSimulationProblem(sdomain, vars, nreals)\n\nA spatial simulation problem on a given spatial domain sdomain in which the variables to be simulated are listed in vars.\n\nFor conditional simulation, the data of the problem is stored in spatial data sdata.\n\nFor unconditional simulation, a list of pairs vars must be provided mapping variable names to their types.\n\nIn both cases, a number nreals of realizations is requested.\n\nExamples\n\nCreate a conditional simulation problem for porosity and permeability with 100 realizations:\n\njulia> SimulationProblem(sdata, sdomain, (:porosity,:permeability), 100)\n\nCreate an unconditional simulation problem for porosity and facies type with 100 realizations:\n\njulia> SimulationProblem(sdomain, (:porosity => Float64, :facies => Int), 100)\n\n\n\n\n\n","category":"type"},{"location":"problems.html#Example-2","page":"Problems","title":"Example","text":"","category":"section"},{"location":"problems.html","page":"Problems","title":"Problems","text":"Define a 2D unconditional simulation problem:","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"using GeoStats # hide\nusing Plots # hide\nusing GeoStatsPlots # hide\ngr(size=(900,300)) # hide\n\n# unconditional simulation problem\nùí¢ = CartesianGrid(100, 100)\nùí´ = SimulationProblem(ùí¢, :Z => Float64, 3)","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"Solve the problem with a few built-in solvers:","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"# few built-in solvers\nS1 = LUGS(:Z => (variogram=GaussianVariogram(range=25.),))\nS2 = FFTGS(:Z => (variogram=GaussianVariogram(range=25.),))\n\n# solve the problem\nsol = [solve(ùí´, S) for S in (S1, S2)]\n\n# plot the solution\nheatmap(sol[1])","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"heatmap(sol[2])","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"Alternatively, define a 2D conditional simulation problem:","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"# unconditional realization\nZ1 = sol[1][1]\n\n# sample observations\nùíü = sample(Z1, 10, replace=false)\n\n# conditional simulation problem\nùí´ = SimulationProblem(ùíü, ùí¢, :Z, 3)","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"And solve it as before:","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"# solve the problem\nsol = solve(ùí´, S1)\n\n# plot the solution\nheatmap(sol)","category":"page"},{"location":"problems.html#Learning","page":"Problems","title":"Learning","text":"","category":"section"},{"location":"problems.html","page":"Problems","title":"Problems","text":"LearningProblem","category":"page"},{"location":"problems.html#GeoStatsBase.LearningProblem","page":"Problems","title":"GeoStatsBase.LearningProblem","text":"LearningProblem(sdata, tdata, task)\n\nA geostatistical learning problem with source data sdata, target data tdata, and learning task.\n\nReferences\n\nHoffimann et al. 2021. Geostatistical Learning: Challenges and Opportunities\n\n\n\n\n\n","category":"type"},{"location":"problems.html#Example-3","page":"Problems","title":"Example","text":"","category":"section"},{"location":"problems.html","page":"Problems","title":"Problems","text":"Please consult the Quickstart for an example or watch our JuliaCon2021 talk:","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"<p align=\"center\">\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/75A6zyn5pIE\" title=\"Geostatistical Learning\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</p>","category":"page"},{"location":"quickstart.html#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"A geostatistical workflow often consists of three steps:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Manipulation of geospatial data\nDefinition of geostatistical problem\nVisualization of problem solution","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"In this section, we walk through these steps to illustrate some of the features of the project. Although we use Plots.jl and the GeoStatsPlots.jl recipes for visualization, we could have used Makie.jl and GeoStatsViz.jl recipes for more advanced 3D visualization examples.","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"using GeoStats\nusing Plots, GeoStatsPlots\ngr(format=:png,size=(800,400),aspectratio=:equal) # hide","category":"page"},{"location":"quickstart.html#Manipulating-data","page":"Quickstart","title":"Manipulating data","text":"","category":"section"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"The workflow starts with the creation of geospatial data, which can be loaded from disk or derived from other Julia variables. For example, given a Julia array (or image), which is not attached to any particular coordinate system:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Z = [10sin(i/10) + j for i in 1:100, j in 1:200]\n\nheatmap(Z)","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"We can georeference the array using the georef function:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Œ© = georef((Z=Z,))","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"The origin and spacing of samples can be specified with:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"georef((Z=Z,), origin=(1.,1.), spacing=(10.,10.))","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"and different geospatial configurations can be obtained with different methods (see Data).","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"We plot the geospatial data and note a few differences compared to the plot shown above:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"plot(Œ©)","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"First, we note that the image was rotated to match the first index i of the array with the horizontal x axis, and the second index j of the array with the vertical y axis. Second, we note that the image was stretched to reflect the real 100x200 size of the CartesianGrid.","category":"page"},{"location":"quickstart.html#Table-interface","page":"Quickstart","title":"Table interface","text":"","category":"section"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Our geospatial data implements the Tables.jl interface, which means that they can be accessed as if they were tables with samples in the rows and variables in the columns. In this case, a special column named geometry is created on the fly, row by row, containing Meshes.jl geometries.","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"For those familiar with the productive DataFrames.jl interface, there is nothing new:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Œ©[1,:]","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Œ©[1,:geometry]","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Œ©.Z","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"However, notice that our implementation performs some clever optimizations behind the scenes to avoid expensive creation of geometries:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Œ©.geometry","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"We can always retrieve the table of attributes (or features) with the function values and the underlying geospatial domain with domain:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"values(Œ©)","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"domain(Œ©)","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"and this can be useful for writing algorithms that depend purely on the geometry or purely on the feature values.","category":"page"},{"location":"quickstart.html#Table-transforms","page":"Quickstart","title":"Table transforms","text":"","category":"section"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"It is easy to design advanced geospatial pipelines that operate on both the table of attributes and the underlying geospatial domain:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"# pipeline with table transforms\npipe = Quantile()\n\n# feed geospatial data to pipeline\nŒ©ÃÑ = Œ© |> pipe\n\n# plot distribution before and after pipeline\ngr(format=:png,size=(800,400),aspectratio=:none) # hide\np1 = histogram(Œ©.Z, color=:gray80, label=\"original\")\np2 = histogram(Œ©ÃÑ.Z, color=:gray80, label=\"quantile\")\nplot(p1, p2, layout=(2,1))","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"These pipelines are revertible meaning that one can transform the data, perform geostatistical modeling, and revert the pipelines to obtain estimates in the original sample space (see Transforms).","category":"page"},{"location":"quickstart.html#Split-apply-combine","page":"Quickstart","title":"Split-apply-combine","text":"","category":"section"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"We provide three macros @groupby, @transform and @combine for powerful geospatial split-apply-combine patterns:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"@transform(Œ©, :W = 2 * :Z * area(:geometry))","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"These macros are very useful for geodata science as they hide the complexity of the geometry column. For more information, check the Split-apply-combine section of the documentation.","category":"page"},{"location":"quickstart.html#Geospatial-views","page":"Quickstart","title":"Geospatial views","text":"","category":"section"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Geospatial data can be viewed at a subset of locations without unnecessary memory allocations:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Œ©·µ• = view(Œ©, 1:10*100)\n\ngr(format=:png,size=(800,400),aspectratio=:equal) # hide\nplot(Œ©·µ•)","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"We plot a random view of the grid to emphasize that views do not preserve geospatial regularity:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"inds = rand(1:100*200, 100)\n\nplot(view(Œ©, inds))","category":"page"},{"location":"quickstart.html#Geospatial-partitions","page":"Quickstart","title":"Geospatial partitions","text":"","category":"section"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Geospatial data can be partitioned with various efficient methods. To demonstrate the operation, we partition our geospatial data view into balls of given radius:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Œ† = partition(Œ©·µ•, BallPartition(5.))\n\nplot(Œ†)","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"or, alternatively, into two halfspaces:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Œ† = partition(Œ©·µ•, BisectFractionPartition((1.,1.), 0.5))\n\nplot(Œ†)","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Geospatial partitions are (lazy) iterators of geospatial views, which are useful in many contexts as it will be shown in the next section. To access a subset of a partition, we use index notation:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"plot(Œ†[1])","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"plot(Œ†[2])","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Various other geospatial operations are defined in the framework besides partitioning. For a complete list, please check the reference guide and the Meshes.jl documentation.","category":"page"},{"location":"quickstart.html#Defining-problems","page":"Quickstart","title":"Defining problems","text":"","category":"section"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Having defined the geospatial data objects, we proceed and define the geostatistical problem to be solved. In this guide, we illustrate geostatistical learning. For other types of geostatistical problems, please check the Problems section of the documentation.","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Let's assume that we have geopatial data with some variable that we want to predict in a supervised learning setting. We load the data from a CSV file, and inspect the available columns:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"using CSV\n\ncsv = CSV.File(\"data/agriculture.csv\")","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Columns band1, band2, ..., band4 represent four satellite bands for different locations (x,y) in this region. The column crop has the crop type for each location that was labeled manually with the purpose of training a learning model. Because the labels are categorical variables, we need to inform the framework the correct scientific type from ScientificTypes.jl:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"table = csv |> Coerce(:crop => Multiclass)\n\nfirst(table.crop, 5)","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"We can now georeference the table and plot some of the variables:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Œ© = georef(table, (:x,:y))\n\nplot(Œ©, (:band4,:crop), ms=0.2, mc=:viridis)","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Similar to a generic statistical learning workflow, we split the data into \"train\" and \"test\" sets. The main difference here is that our geospatial split function accepts a separating plane specified by its normal direction (1,-1):","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Œ©s, Œ©t = split(Œ©, 0.2, (1.,-1.))\n\nplot(domain(Œ©s), ms=0.2, mc=:royalblue)\nplot!(domain(Œ©t), ms=0.2, mc=:gray)","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"We can visualize the domain of the \"train\" (or source) set Œ©s in blue, and the domain of the \"test\" (or target) set Œ©t in gray. We reserved 20% of the samples to Œ©s and 80% to Œ©t. Internally, this geospatial split function is implemented in terms of efficient geospatial partitions, which were illustrated in the previous section.","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Let's define the learning task and the geostatistical learning problem. We want to predict the crop type based on the four satellite bands. We will train the model in Œ©s where labels are available, and apply it to Œ©t, which is our target:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"feats = [:band1,:band2,:band3,:band4]\nlabel = :crop\n\nùíØ = ClassificationTask(feats, label)\n\nùí´ = LearningProblem(Œ©s, Œ©t, ùíØ)","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"GeoStats.jl is integrated with the MLJ.jl project, which means that we can solve geostatistical learning problems with more than 150 classical learning models:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"using MLJ\n\n‚Ñ≥ = MLJ.@load DecisionTreeClassifier pkg=DecisionTree\n\n‚Ñí = PointwiseLearn(‚Ñ≥())","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"In this example, we selected a PointwiseLearn strategy to solve the geostatistical learning problem. This strategy consists of applying the learning model pointwise for every location in the geospatial data:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Œ©ÃÇt = solve(ùí´, ‚Ñí)","category":"page"},{"location":"quickstart.html#Plotting-solutions","page":"Quickstart","title":"Plotting solutions","text":"","category":"section"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"We note that the solution to a geostatistical learning problem is a geospatial data object, and we can inspect it with the same methods already described above. This also means that we can plot the solution directly, side by side with the true label in this synthetic example:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"pÃÇ = plot(Œ©ÃÇt, ms=0.2, mc=:viridis, title=\"crop (prediction)\")\np = plot(Œ©t, (:crop,), ms=0.2, mc=:viridis)\n\nplot(pÃÇ, p)","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Visually, it seems that the learning model is predicting the crop type. We can also estimate the generalization error of the geostatistical solver with geostatistical validation methods such as block cross-validation and leave-ball-out, but these methods deserve a separate tutorial.","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"With this example we conclude the basic workflow. To get familiar with other features of the project, please check the tutorials and the reference guide.","category":"page"},{"location":"validation.html#Validation","page":"Validation","title":"Validation","text":"","category":"section"},{"location":"validation.html","page":"Validation","title":"Validation","text":"GeoStats.jl was designed to, among other things, facilitate rigorous scientific comparison of different geostatistical solvers in the literature. As a user of geostatistics, you may be interested in applying various solvers on a given data set and pick the ones with best performance. As a researcher in the field, you may be interested in benchmarking your new method against other established methods.","category":"page"},{"location":"validation.html","page":"Validation","title":"Validation","text":"Errors of geostatistical solvers can be estimated on given geostatistical problems:","category":"page"},{"location":"validation.html","page":"Validation","title":"Validation","text":"error(::Any, ::Any, ::ErrorEstimationMethod)","category":"page"},{"location":"validation.html#Base.error-Tuple{Any, Any, ErrorEstimationMethod}","page":"Validation","title":"Base.error","text":"error(solver, problem, method)\n\nEstimate error of solver in a given problem with error estimation method.\n\n\n\n\n\n","category":"method"},{"location":"validation.html","page":"Validation","title":"Validation","text":"Below is the list of currently implemented error estimation methods.","category":"page"},{"location":"validation.html#Leave-one-out","page":"Validation","title":"Leave-one-out","text":"","category":"section"},{"location":"validation.html","page":"Validation","title":"Validation","text":"LeaveOneOut","category":"page"},{"location":"validation.html#GeoStatsBase.LeaveOneOut","page":"Validation","title":"GeoStatsBase.LeaveOneOut","text":"LeaveOneOut(; loss=Dict())\n\nLeave-one-out validation. Optionally, specify loss function from LossFunctions.jl for some of the variables.\n\nReferences\n\nStone. 1974. Cross-Validatory Choice and Assessment of Statistical Predictions\n\n\n\n\n\n","category":"type"},{"location":"validation.html#Leave-ball-out","page":"Validation","title":"Leave-ball-out","text":"","category":"section"},{"location":"validation.html","page":"Validation","title":"Validation","text":"LeaveBallOut","category":"page"},{"location":"validation.html#GeoStatsBase.LeaveBallOut","page":"Validation","title":"GeoStatsBase.LeaveBallOut","text":"LeaveBallOut(ball; loss=Dict())\n\nLeave-ball-out (a.k.a. spatial leave-one-out) validation. Optionally, specify loss function from the LossFunctions.jl package for some of the variables.\n\nLeaveBallOut(radius; loss=Dict())\n\nBy default, use Euclidean ball of given radius in space.\n\nReferences\n\nLe Rest et al. 2014. Spatial leave-one-out cross-validation for variable selection in the presence of spatial autocorrelation\n\n\n\n\n\n","category":"type"},{"location":"validation.html#K-fold","page":"Validation","title":"K-fold","text":"","category":"section"},{"location":"validation.html","page":"Validation","title":"Validation","text":"KFoldValidation","category":"page"},{"location":"validation.html#GeoStatsBase.KFoldValidation","page":"Validation","title":"GeoStatsBase.KFoldValidation","text":"KFoldValidation(k; shuffle=true, loss=Dict())\n\nk-fold cross-validation. Optionally, shuffle the data, and specify loss function  from LossFunctions.jl for some of the variables.\n\nReferences\n\nGeisser, S. 1975. The predictive sample reuse method with applications\nBurman, P. 1989. A comparative study of ordinary cross-validation, v-fold cross-validation and the repeated learning-testing methods\n\n\n\n\n\n","category":"type"},{"location":"validation.html#Block","page":"Validation","title":"Block","text":"","category":"section"},{"location":"validation.html","page":"Validation","title":"Validation","text":"BlockValidation","category":"page"},{"location":"validation.html#GeoStatsBase.BlockValidation","page":"Validation","title":"GeoStatsBase.BlockValidation","text":"BlockValidation(sides; loss=Dict())\n\nCross-validation with blocks of given sides. Optionally, specify loss function from LossFunctions.jl for some of the variables. If only one side is provided, then blocks become cubes.\n\nReferences\n\nRoberts et al. 2017. Cross-validation strategies for data with temporal, spatial, hierarchical, or phylogenetic structure\nPohjankukka et al. 2017. Estimating the prediction performance of spatial models via spatial k-fold cross-validation\n\n\n\n\n\n","category":"type"},{"location":"validation.html#Weighted","page":"Validation","title":"Weighted","text":"","category":"section"},{"location":"validation.html","page":"Validation","title":"Validation","text":"WeightedValidation","category":"page"},{"location":"validation.html#GeoStatsBase.WeightedValidation","page":"Validation","title":"GeoStatsBase.WeightedValidation","text":"WeightedValidation(weigthing, folding; lambda=1.0, loss=Dict())\n\nAn error estimation method which samples are weighted with weighting method and split into folds with folding method. Weights are raised to lambda power in [0,1]. Optionally, specify loss function from LossFunctions.jl for some of the variables.\n\nReferences\n\nSugiyama et al. 2006. Importance-weighted cross-validation for covariate shift\nSugiyama et al. 2007. Covariate shift adaptation by importance weighted cross validation\n\n\n\n\n\n","category":"type"},{"location":"validation.html#Density-ratio","page":"Validation","title":"Density-ratio","text":"","category":"section"},{"location":"validation.html","page":"Validation","title":"Validation","text":"DensityRatioValidation","category":"page"},{"location":"validation.html#GeoStatsBase.DensityRatioValidation","page":"Validation","title":"GeoStatsBase.DensityRatioValidation","text":"DensityRatioValidation(k; [parameters])\n\nDesntity ratio validation where weights are first obtained with density ratio estimation, and then used in k-fold weighted cross-validation.\n\nParameters\n\nshuffle   - Shuffle the data before folding (default to true)\nestimator - Density ratio estimator (default to LSIF())\noptlib    - Optimization library (default to default_optlib(estimator))\nlambda    - Power of density ratios (default to 1.0)\n\nPlease see DensityRatioEstimation.jl for a list of supported estimators.\n\nReferences\n\nHoffimann et al. 2020. Geostatistical Learning: Challenges and Opportunities\n\n\n\n\n\n","category":"type"},{"location":"resources/ecosystem.html#Ecosystem","page":"Ecosystem","title":"Ecosystem","text":"","category":"section"},{"location":"resources/ecosystem.html","page":"Ecosystem","title":"Ecosystem","text":"The Julia ecosystem for geospatial modeling is maturing very quickly as the result of multiple initiatives such as JuliaEarth, JuliaClimate, and JuliaGeo. Each of these initiatives is associated with a different set of challenges that ultimatively determine the types of packages that are being developed in the corresponding GitHub organizations. In this section, we try to clarify what is available to first-time users of the language.","category":"page"},{"location":"resources/ecosystem.html","page":"Ecosystem","title":"Ecosystem","text":"<img src=\"https://avatars.githubusercontent.com/u/59541313?s=200&v=4\" width=\"150\">\n<img src=\"https://avatars.githubusercontent.com/u/41747566?s=200&v=4\" width=\"150\">\n<img src=\"https://avatars.githubusercontent.com/u/10616454?s=200&v=4\" width=\"150\">","category":"page"},{"location":"resources/ecosystem.html#JuliaEarth","page":"Ecosystem","title":"JuliaEarth","text":"","category":"section"},{"location":"resources/ecosystem.html","page":"Ecosystem","title":"Ecosystem","text":"Originally created to host the GeoStats.jl stack of packages, this initiative is primarily concerned with statistical modeling of geospatial processes. Due to the various  applications of geostatistics in the subsurface of the Earth, most of our packages were developed to work efficiently with both 2D and 3D geometries.","category":"page"},{"location":"resources/ecosystem.html","page":"Ecosystem","title":"Ecosystem","text":"Unlike other initiatives, JuliaEarth is 100% Julia by design. This means that we do not rely on external libraries such as GDAL and Proj4 in our implementations. Consequently, we may lack important features at this point in time.","category":"page"},{"location":"resources/ecosystem.html#JuliaClimate","page":"Ecosystem","title":"JuliaClimate","text":"","category":"section"},{"location":"resources/ecosystem.html","page":"Ecosystem","title":"Ecosystem","text":"The most recent of the three initiatives, JuliaClimate has been created to address specific challenges in climate modeling. One of these challenges is simply getting access to climate data in a format that is easy to consume in Julia. Packages such as INMET.jl and CDSAPI.jl serve this purpose and are quite nice to work with. Additionally, other packages such as ClimateTools.jl were developed to help with the computation of climate indices on 2D grids that are standard in climate sciences.","category":"page"},{"location":"resources/ecosystem.html#JuliaGeo","page":"Ecosystem","title":"JuliaGeo","text":"","category":"section"},{"location":"resources/ecosystem.html","page":"Ecosystem","title":"Ecosystem","text":"Focused on bringing well-established external libraries to Julia, JuliaGeo provides packages that are widely used by the geospatial community from other programming languages. GDAL.jl, Proj4.jl and LibGEOS.jl are good examples of such packages, which are often used as indirect dependencies in Julia projects. Additionally, this initiative provides packages for IO such as Shapefile.jl and GeoJSON.jl that are written in pure Julia and can be easily installed anywhere.","category":"page"},{"location":"resources/ecosystem.html#Miscellaneous","page":"Ecosystem","title":"Miscellaneous","text":"","category":"section"},{"location":"resources/ecosystem.html","page":"Ecosystem","title":"Ecosystem","text":"Besides the three main initiatives listed above, various other initiatives can be found that are related to computational geometry and visualization of geometric models. We highlight the Meshes.jl project hosted in the JuliaGeometry organization, the Makie.jl project hosted in the JuliaPlots organization, as well as other packages for loading/saving mesh data such as Gmsh.jl, PlyIO.jl, ReadVTK.jl and WriteVTK.jl.","category":"page"},{"location":"plotting.html#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"Most objects defined in GeoStats.jl can be plotted directly with Plots.jl or  Makie.jl. In order to do this,  first install GeoStatsPlots.jl (for Plots.jl) or GeoStatsViz.jl  (for Makie.jl), which define recipes for each plotting library. Additional plots are listed below that can be useful for geostatistical analysis.","category":"page"},{"location":"plotting.html#Built-in","page":"Plotting","title":"Built-in","text":"","category":"section"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"A hscatter plot between two variables var1 and var2 (possibly with var2 = var1) is a simple scatter plot in which the dots represent all ordered pairs of values of var1 and var2 at a given lag h.","category":"page"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"using GeoStats\nusing Plots, GeoStatsPlots\ngr(size=(800,300)) # hide\n\nùíü = georef((Z=[10sin(i/10) + j for i in 1:100, j in 1:200],))\n\nùíÆ = sample(ùíü, 500)\n\np1 = hscatter(ùíÆ, :Z, lag=0)\np2 = hscatter(ùíÆ, :Z, lag=20)\np3 = hscatter(ùíÆ, :Z, lag=40)\np4 = hscatter(ùíÆ, :Z, lag=60)\n\nplot(p1, p2, p3, p4)","category":"page"},{"location":"plotting.html#PairPlots.jl","page":"Plotting","title":"PairPlots.jl","text":"","category":"section"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"The PairPlots.jl package provides the corner plot that can be used with any table, including tables of attributes obtained with the values function.","category":"page"},{"location":"plotting.html#StatsPlots.jl","page":"Plotting","title":"StatsPlots.jl","text":"","category":"section"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"The StatsPlots.jl package provides various statistical plots such as boxplot, dotplot, violin and other plots commonly used in statistical workflows.","category":"page"},{"location":"index.html#GeoStats.jl","page":"Home","title":"GeoStats.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"An extensible framework for high-performance geostatistics in Julia.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"<p align=\"center\">\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/75A6zyn5pIE\" title=\"Geostatistical Learning\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</p>","category":"page"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"In many fields of science, such as mining engineering, hydrogeology, petroleum engineering, and environmental sciences, traditional statistical methods fail to provide unbiased estimates of resources due to the presence of geospatial correlation. Geostatistics (a.k.a. geospatial statistics) is the branch of statistics developed to overcome this limitation. Particularly, it is the branch that takes geospatial coordinates of data into account.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"GeoStats.jl is an attempt to bring together bleeding-edge research in the geostatistics community into a comprehensive framework for geospatial modeling, as well as to empower researchers and practioners with a toolkit for fast assessment of different modeling approaches.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The design of this project is the result of many years developing geostatistical software. I hope that it can serve to promote more collaboration between geostatisticians around the globe and to standardize this incredible field of research. If you would like to help support the project, please star the repository (Image: STARS) and share it with your colleagues. If you would like to extend the framework with new geostatistical solvers, please check the Developer guide.","category":"page"},{"location":"index.html#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you find this project useful in your work, please consider citing it: ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: JOSS) (Image: DOI)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"@ARTICLE{Hoffimann2018,\n  title={GeoStats.jl ‚Äì High-performance geostatistics in Julia},\n  author={Hoffimann, J√∫lio},\n  journal={Journal of Open Source Software},\n  publisher={The Open Journal},\n  volume={3},\n  pages={692},\n  number={24},\n  ISSN={2475-9066},\n  DOI={10.21105/joss.00692},\n  url={https://dx.doi.org/10.21105/joss.00692},\n  year={2018},\n  month={Apr}\n}","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We ‚ù§ to see our list of publications growing.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Get the latest stable release with Julia's package manager:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"] add GeoStats","category":"page"},{"location":"index.html#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A set of Pluto notebooks demonstrating the current functionality of the project is available in GeoStatsTutorials with an accompanying series of videos:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"<p align=\"center\">\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/yDIK9onnZVw\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</p>","category":"page"},{"location":"index.html#Quick-example","page":"Home","title":"Quick example","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Below is a quick preview of the high-level API:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using GeoStats\nusing Plots, GeoStatsPlots\ngr(size=(900,400)) # hide\n\n# attribute table\ntable = (Z=[1.,0.,1.],)\n\n# coordinates for each row\ncoord = [(25.,25.), (50.,75.), (75.,50.)]\n\n# georeference data\nùíü = georef(table, coord)\n\n# estimation domain\nùí¢ = CartesianGrid(100, 100)\n\n# estimation problem\nproblem = EstimationProblem(ùíü, ùí¢, :Z)\n\n# choose a solver from the list of solvers\nsolver = Kriging(\n  :Z => (variogram=GaussianVariogram(range=35.),)\n)\n\n# solve the problem\nsolution = solve(problem, solver)\n\n# plot the solution\ncontourf(solution, clabels=true)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For a more detailed example, please consult the Quickstart.","category":"page"},{"location":"index.html#Project-organization","page":"Home","title":"Project organization","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The project is split into various packages:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Package Description\nGeoStats.jl Main package reexporting full stack of packages for geostatistics.\nVariography.jl Variogram estimation and modeling, and related tools.\nKrigingEstimators.jl High-performance implementations of Kriging estimators.\nPointPatterns.jl Geospatial point pattern analysis and synthesis.\nGeoClustering.jl Geostatistical clustering (a.k.a. domaining).\nGeoStatsSolvers.jl Built-in geostatistical solvers.\nGeoStatsBase.jl Base package with core definitions.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Other packages can be installed separately for additional functionality:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Package Description\nGeoStatsImages.jl Training images for multiple-point simulation.\nGeoTables.jl (Down)load geospatial tables in various formats.\nDrillHoles.jl Desurvey/composite drillhole data.\nGslibIO.jl Load/save (extended) GSLIB files.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Besides the packages above, the project can be extended with solver packages.","category":"page"},{"location":"index.html#Community-channels","page":"Home","title":"Community channels","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"We invite you to join our community channels. There you will meet other fellow geostatisticians who like to code. We are very friendly, come say hi! üòÑüåé","category":"page"},{"location":"about/citing.html","page":"Citing","title":"Citing","text":"If you find GeoStats.jl useful in your work, please consider citing it:","category":"page"},{"location":"about/citing.html","page":"Citing","title":"Citing","text":"(Image: JOSS) (Image: DOI)","category":"page"},{"location":"about/citing.html","page":"Citing","title":"Citing","text":"@ARTICLE{Hoffimann2018,\n  title={GeoStats.jl ‚Äì High-performance geostatistics in Julia},\n  author={Hoffimann, J√∫lio},\n  journal={Journal of Open Source Software},\n  publisher={The Open Journal},\n  volume={3},\n  pages={692},\n  number={24},\n  ISSN={2475-9066},\n  DOI={10.21105/joss.00692},\n  url={https://dx.doi.org/10.21105/joss.00692},\n  year={2018},\n  month={Apr}\n}","category":"page"}]
}
